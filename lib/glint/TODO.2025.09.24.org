* Range-based =for= Loop

=for <identifier> in <container-expression> <body-expression>=

=for x in y z;=

* =print=

Basically, I think I want =print= to just be syntactic sugar for mapping all given arguments to =puts()= via =format()=.

=print "foo:" 42;= should print =foo:42=. Via =puts("foo:");puts(format(42));=.

** Custom Types

Just implement =format : [byte](:T) { ... }= for your type, and rely on function overloading for everything to "just work"â„¢.

** String Interpolation

Eventually we will probably want a way to do =printf "foo:{} bar:{}\n" 42 27;= or something like that.

* Byte Literals

Basically, a way to convert characters to their ASCII byte representation. We just need a syntax, basically.

You'll run into this writing code that gets the string representation of a number, and the other way around.

=@"a"[0]= is just UGLY (even if it may work).

=b"a"= is okay, but still a bit verbose. We want the byte/character itself to be most prevalent.

Or, think of this, a single-length byte array known at compile time could be implicitly convertible to it's single element. So, just use ='a'= or ="a"=. The problem is that, then, a single-length string literal is implicitly convertible to an integer, and that kind of may cause bugs/be unexpected?

* <Development Aid> Tests Recall

Basically, when you run =glinttests=, save the results. If old results are found, show comparison between old results and new results (i.e. "this test is NOW FAILING").
