* If a (mangled) symbol gets long enough, we should just hash it and use that symbol.

We'll just pick a long enough limit where the resulting hash is pretty much guaranteed to be unique, or something. Is a hash written with 64 characters not enough to cover just about everything? Then, we could apply this only to functions over a certain length that makes the chosen hash function very unlikely to collide. We could even use a hash function that intentionally produces pretty short hashes (i.e. =adler32=). Or even =crc32= for simplicity.

* Iterator Invalidation Caught at Compile-Time

If you write a ranged =for= loop, supplying a given container expression, then, if that container expression is modified /at all/ in the =for='s body, raise an error.

I'm not sure if this is even possible, or how one would go about implementing it, but it would be a really, /really/ useful language feature.

* =enumerate=

Basically, a =for=-like looping mechanism that enumerates all values starting at 0 up until =<container>.size=.

Index-based ranged for.

=enumerate (<index_identifier>, <value_identifier>) in <container> <body>;=

Enumerate values in a given container, binding =<index_identifier>= to the index and =<value_identifier>= to a reference to the value within the container at that index.

Emits code in the form of:
NOTE: Should we cache =<container>= expression, or evaluate it multiple times?
#+begin_example
cfor
  <index_identifier> :: 0;
  <index_identifier> != <container>.size;
  <index_identifier> += 1;
  {
    <value_identifier> :: @<container>.data[<index_identifier>];
    <body>;
  };
#+end_example

There would be an alternate form where the value identifier isn't supplied that simply loops over the valid indices of values in the given container, no value binding.

I believe =enumerate= is necessary because it's currently not trivial to loop over values 0 to 10 (have to use ugly cfor). With =enumerate= you just need a struct with a =size= member set to 10, and you can loop away.

** Compound initialisers with ranged =for= and such.

Basically, I want to be able to do something like:
=enumerate i in !{ .size 10 }, print i;=

The compound literal meets the necessary "requirements" of =enumerate= (having a =size= member), so it should be able to be used in this fashion. I'm not actually sure if this would work out of the box or what might need to happen for it to work, though.
