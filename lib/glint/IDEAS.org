* Iterator Invalidation Caught at Compile-Time

If you write a ranged =for= loop, supplying a given container expression, then, if that container expression is modified /at all/ in the =for='s body, raise an error.

I'm not sure if this is even possible, or how one would go about implementing it, but it would be a really, /really/ useful language feature.

* =enumerate=

Basically, a =for=-like looping mechanism that enumerates all values starting at 0 up until =<container>.size=.

Index-based ranged for.

=enumerate (<index_identifier>, <value_identifier>) in <container> <body>;=

Enumerate values in a given container, binding =<index_identifier>= to the index and =<value_identifier>= to a reference to the value within the container at that index.

Emits code in the form of:
NOTE: Should we cache =<container>= expression, or evaluate it multiple times?
#+begin_example
cfor
  <index_identifier> :: 0;
  <index_identifier> != <container>.size;
  <index_identifier> += 1;
  {
    <value_identifier> :: @<container>.data[<index_identifier>];
    <body>;
  };
#+end_example

There would be an alternate form where the value identifier isn't supplied that simply loops over the valid indices of values in the given container, no value binding.

I believe =enumerate= is necessary because it's currently not trivial to loop over values 0 to 10 (have to use ugly cfor). With =enumerate= you just need a struct with a =size= member set to 10, and you can loop away.

** Compound initialisers with ranged =for= and such.

Basically, I want to be able to do something like:
=enumerate i in !{ .size 10 }, print i;=

The compound literal meets the necessary "requirements" of =enumerate= (having a =size= member), so it should be able to be used in this fashion. I'm not actually sure if this would work out of the box or what might need to happen for it to work, though.
