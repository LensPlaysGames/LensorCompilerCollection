* Iterator Invalidation Caught at Compile-Time

If you write a ranged =for= loop, supplying a given container expression, then, if that container expression is modified /at all/ in the =for='s body, raise an error.

I'm not sure if this is even possible, or how one would go about implementing it, but it would be a really, /really/ useful language feature.

* =enumerate=

Basically, a =for=-like looping mechanism that enumerates all values starting at 0 up until =<container>.size=.

Index-based ranged for.

=enumerate (<index_identifier>, <value_identifier>) in <container> <body>;=

Enumerate values in a given container, binding =<index_identifier>= to the index and =<value_identifier>= to a reference to the value within the container at that index.

Emits code in the form of:
NOTE: Should we cache =<container>= expression, or evaluate it multiple times?
#+begin_example
cfor
  <index_identifier> :: 0;
  <index_identifier> != <container>.size;
  <index_identifier> += 1;
  {
    <value_identifier> :: @<container>.data[<index_identifier>];
    <body>;
  };
#+end_example

There would be an alternate form where the value identifier isn't supplied that simply loops over the valid indices of values in the given container, no value binding.

I believe =enumerate= is necessary because it's currently not trivial to loop over values 0 to 10 (have to use ugly cfor). With =enumerate= you just need a struct with a =size= member set to 10, and you can loop away.

** Compound initialisers with ranged =for= and such.

Basically, I want to be able to do something like:
=enumerate i in !{ .size 10 }, print i;=

The compound literal meets the necessary "requirements" of =enumerate= (having a =size= member), so it should be able to be used in this fashion. I'm not actually sure if this would work out of the box or what might need to happen for it to work, though.

* AST Macros

Basically, it's going to be like a conversion method to go from one AST to another.

#+begin_src
  (block (name = "x")) -> (block (unary_dereference (name = "x")))
#+end_src

We already sort-of have AST Macros in the form of =:expr= lexer macro argument selector.

#+begin_src glint-ts
  macro double $x:expr emits 2 $x endmacro

  double 2 + 2;
#+end_src

For some reason I want a more concrete way of doing this, though. Or to operate on the values in code more concretely, I guess.

** NOTE: Deprecated in favor of templates

Basically, a template /is/ an AST macro. Technically differs because the template output is parsed rather than generated by code run at compile-time, but it's not really a big deal to me, as the same issues macros solve, templates also do.

Like so:
#+begin_src
  foo :: template(x : expr) @x;
#+end_src
