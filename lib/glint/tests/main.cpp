#include <langtest/langtest.hh>

#include <lcc/context.hh>
#include <lcc/format.hh>
#include <lcc/ir/ir.hh>
#include <lcc/ir/module.hh>
#include <lcc/target.hh>
#include <lcc/utils.hh>

#include <glint/ast.hh>
#include <glint/ir_gen.hh>
#include <glint/parser.hh>
#include <glint/sema.hh>

#include <algorithm>
#include <filesystem>
#include <string>
#include <string_view>
#include <unordered_map>

static lcc::utils::Colours C{true};
using lcc::utils::Colour;

/// Default target.
const lcc::Target* default_target =
#if defined(LCC_PLATFORM_WINDOWS)
    lcc::Target::x86_64_windows;
#elif defined(__APPLE__) or defined(__linux__)
    lcc::Target::x86_64_linux;
#else
#    error "Unsupported target"
#endif

/// Default format
const lcc::Format* default_format = lcc::Format::gnu_as_att_assembly;

bool option_print;
bool option_suppress{true};

struct GlintTest : langtest::Test {
    static bool warning_reported(lcc::Context& ctx) {
        return lcc::rgs::any_of(
            ctx.diagnostics(),
            [](const lcc::Context::DiagnosticReport d) {
                return d.kind == lcc::Diag::Kind::Warning;
            }
        );
    }

    struct ParseInfo {
        std::unique_ptr<lcc::glint::Module> mod{};
        std::vector<lcc::Context::DiagnosticReport> diagnostics{};
    };
    /// Parse test source as Glint
    auto parse(lcc::Context& context) -> ParseInfo {
        // Parse Glint source code using the Glint parser into a Glint module for Glint fun.
        // NOTE: While we can get "location info" by creating a file here, it
        // isn't really useful as it doesn't point to a real file.
        auto& f = context.create_file(
            name,
            std::vector<char>{source.begin(), source.end()}
        );
        auto mod = lcc::glint::Parser::Parse(&context, f);

        // Save diagnostics reported during parsing, and clear the context's
        // diagnostics so that we can separate parse/sema diagnostics.
        auto parse_diagnostics = context.diagnostics();
        context.diagnostics().clear();

        return {std::move(mod), parse_diagnostics};
    };

    // NOTE: Returns true if test does not expect IR.
    auto perform_ir_match(lcc::Context& context, lcc::glint::Module& mod) -> bool {
        if (ir.empty()) return true;

        // Parse expected IRGen IR
        // fmt::print("EXPECTED IR SPAN:\n{}\n", ir);
        std::vector<char> ir_v = {ir.begin(), ir.end()};
        auto& ir_f = context.create_file("ir_source.lcc", ir_v);
        auto expected_ir = lcc::Module::Parse(&context, ir_f);
        if (not expected_ir) {
            fmt::print("Error parsing expected IR for test {}\n", name);
            return false;
        }
        auto* got_ir = lcc::glint::IRGen::Generate(&context, mod);

        // For every function in the expected IR, check that the function also
        // exists in the IR we got.
        for (auto* expected_func : expected_ir->code()) {
            // We want to find the function in the IR generated by the test by name;
            // that is, we want to find it if any of it's names match the expected
            // function's name (that we parsed from the expected test output).
            auto got_func_in_ir
                = got_ir->function_by_one_of_names(expected_func->names());
            if (not got_func_in_ir) {
                fmt::print(
                    "IR MISMATCH: Expected function {} to be in IR, but didn't find it\n"
                    "{}",
                    expected_func->names().at(0).name,
                    got_ir->as_lcc_ir(true)
                );

                return false;
            }
            auto* got_func = *got_func_in_ir;
            // TODO: There are other ways functions might not be equivalent, but I
            // don't think we should handle each and every one of those here. We
            // should implement '==', or something similar, on lcc::Function itself, I
            // think.

            if (expected_func->blocks().size() != got_func->blocks().size()) {
                fmt::print(
                    "IR MISMATCH: Block count in function {}\n",
                    expected_func->names().at(0).name
                );

                return false;
            }

            for (size_t block_i = 0; block_i < expected_func->blocks().size(); ++block_i) {
                auto* expected_block = expected_func->blocks().at(block_i);
                auto* got_block = got_func->blocks().at(block_i);

                if (expected_func->blocks().size() != got_func->blocks().size()) {
                    fmt::print(
                        "IR MISMATCH: Instruction count in block {} in function {}\n",
                        expected_block->name(),
                        expected_func->names().at(0).name
                    );

                    return false;
                }

                std::unordered_map<lcc::Inst*, lcc::Inst*> expected_to_got{};
                for (size_t inst_i = 0; inst_i < expected_block->instructions().size(); ++inst_i) {
                    auto* expected_inst = expected_block->instructions().at(inst_i);
                    auto* got_inst = got_block->instructions().at(inst_i);
                    expected_to_got[expected_inst] = got_inst;

                    if (expected_inst->kind() != got_inst->kind()) {
                        // TODO: Maybe have this behind a "--verbose-ir" CLI flag or something
                        // fmt::print("\nExpected IR:\n");
                        // expected_func->print();
                        // fmt::print("Got IR:\n");
                        // got_func->print();

                        fmt::print(
                            "IR MISMATCH: Expected instruction (1) but got instruction (2) in block {} in function {}\n",
                            expected_block->name(),
                            expected_func->names().at(0).name
                        );

                        fmt::print("(1): ");
                        expected_inst->print();
                        fmt::print("{}\n", C(lcc::utils::Colour::Reset));

                        fmt::print("(2): ");
                        got_inst->print();
                        fmt::print("{}\n", C(lcc::utils::Colour::Reset));

                        return false;
                    }

                    // Compare instruction children and ensure they point to equivalent
                    // places (i.e. got_inst->child[0] == expected_inst->child[0], but not
                    // literally equals, just equals the one that represents. Basically, we
                    // will need a map of expected_inst to got_inst so we can do this
                    // comparison properly).
                    auto expected_children = expected_inst->children();
                    auto got_children = got_inst->children();

                    size_t child_i = 0;
                    while (
                        expected_children.begin() != expected_children.end()
                        and got_children.begin() != got_children.end()
                    ) {
                        auto* expected_child = *expected_children.begin();
                        auto* got_child = *got_children.begin();
                        if (auto* expected_child_inst = lcc::cast<lcc::Inst>(expected_child)) {
                            if (expected_to_got[expected_child_inst] != got_child) {
                                fmt::print(
                                    "IR MISMATCH: Expected operand {} (zero-based) of instruction (1) to reference (2), but it instead references (3)\n",
                                    child_i
                                );

                                fmt::print("(1): ");
                                got_inst->print();
                                fmt::print("{}\n", C(lcc::utils::Colour::Reset));

                                fmt::print("(2): ");
                                expected_child_inst->print();
                                fmt::print("{}\n", C(lcc::utils::Colour::Reset));

                                fmt::print("(3): ");
                                expected_to_got[expected_child_inst]->print();
                                fmt::print("{}\n", C(lcc::utils::Colour::Reset));

                                return false;
                            }
                        }
                        // Advance iterators
                        ++expected_children.begin();
                        ++got_children.begin();
                        ++child_i;
                    }
                }
            }
        }

        return true;
    }

    bool test_passed(
        bool failed_parse,
        bool failed_check,
        bool warned_parse,
        bool warned_check,
        bool matched_ast,
        bool matched_ir
    ) {
        // Now we just have to determine if the test processed above actually
        // passed. To do this, we will go through all possible fail cases, and
        // return false in those cases, since the test failed. If no failure case
        // returns false, then the test must have passed, and it will return true.

        switch (warning_point) {
            case langtest::Test::WarningPoint::Syntax:
                if (not warned_parse) {
                    fmt::print("Expected warning from parser, but one was not emitted.\n");
                    return false;
                }
                break;

            case langtest::Test::WarningPoint::Sema:
                if (not warned_check) {
                    fmt::print("Expected warning from sema, but one was not emitted.\n");
                    return false;
                }
                break;

            // No warning point means no warnings are expected.
            case langtest::Test::WarningPoint::None:
                if (warned_parse or warned_check) {
                    fmt::print("Expected no warnings, but warnings were emitted.\n");
                    return false;
                }
                break;
        }

        switch (failure_point) {
            case langtest::Test::FailurePoint::Syntax:
                if (not failed_parse) {
                    fmt::print("Expected parse failure, but parsing succeeded.\n");
                    return false;
                }
                break;

            // Failure Point at sema means parsing is expected to succeed.
            case langtest::Test::FailurePoint::Sema:
                if (failed_parse) {
                    fmt::print("Expected sema failure, which implies parsing success, but parsing failed.\n");
                    return false;
                }
                if (not failed_check) {
                    fmt::print("Expected sema failure, but sema succeeded.\n");
                    return false;
                }
                break;

            case langtest::Test::FailurePoint::None:
                // No failure point means parsing and checking is expected to succeed.
                if (failed_parse) {
                    fmt::print("Expected no failures, but parsing failed.\n");
                    return false;
                }
                if (failed_check) {
                    fmt::print("Expected no failures, but sema failed.\n");
                    return false;
                }
                // No failure point means matching is performed, and expected to succeed.
                if (not matched_ast) {
                    fmt::print("Expected AST to match, but AST did not match.\n");
                    return false;
                }
                if (not matched_ir) {
                    fmt::print("Expected IR to match, but IR did not match.\n");
                    return false;
                }
                break;
        }

        // Stop point mostly has to do with how a test is processed, rather than
        // affecting how a test passes.
        switch (stop_point) {
            case langtest::Test::StopPoint::Syntax:
            case langtest::Test::StopPoint::None:
                break;
        }

        return true;
    }

    auto run() -> bool {
        LCC_ASSERT(not name.empty(), "Refusing to run test with empty name");

        // Parse test source as Glint

        // TODO: Get target from "-t" or "--target" command line option.
        // TODO: Get format from "-f" or "--format" command line option.
        lcc::Context context{
            default_target,
            default_format,
            lcc::Context::Options{
                lcc::Context::DoNotUseColour,
                lcc::Context::DoNotPrintAST,
                lcc::Context::DoNotStopatLex,
                lcc::Context::DoNotStopatSyntax,
                lcc::Context::DoNotStopatSema,
                lcc::Context::DoNotPrintMIR,
                lcc::Context::DoNotStopatMIR //
            } //
        };
        if (option_suppress)
            context.suppress_diagnostics();

        auto parse_info = parse(context);
        bool failed_parse = context.has_error();
        bool warned_parse = warning_reported(context);

        bool do_checking = should_check() and not failed_parse;

        // If we do checking, assume we fail until we don't. If we don't check, we
        // can't fail what we don't do.
        bool failed_check{do_checking};
        bool warned_check{false};
        if (do_checking) {
            // Perform type-checking
            lcc::glint::Sema::Analyse(&context, *parse_info.mod, true);
            failed_check = context.has_error();
            warned_check = warning_reported(context);
        }

        // Only match if test is expected NOT to fail, and hasn't failed parsing
        // or checking (if checking was performed).
        bool do_matching = failure_point == FailurePoint::None
                       and not failed_parse and not failed_check;

        bool ast_matches{true};
        bool ir_matches{true};
        if (do_matching) {
            auto* root = parse_info.mod->top_level_function()->body();
            ast_matches = perform_match<lcc::glint::Expr>(root, matcher);
            ir_matches = perform_ir_match(context, *parse_info.mod);
        }

        bool passed = test_passed(
            failed_parse,
            failed_check,
            warned_parse,
            warned_check,
            ast_matches,
            ir_matches
        );

        // NOTE: Even if we shouldn't print, the parsing/semantic analysis that
        // failed almost certainly printed something of some kind, so we are kind
        // of forced to print something just to delineate what that output came
        // from.
        if (not passed) {
            fmt::print("  {}: {}FAIL{}\n\n", name, C(Colour::Red), C(Colour::Reset));
            if (not ast_matches) {
                std::string expected = matcher.print();
                std::string got = langtest::print_node<lcc::glint::Expr>(parse_info.mod->top_level_function()->body());

                // find_different_from_begin()
                size_t diff_begin{0};
                for (; diff_begin < expected.size() and diff_begin < got.size(); ++diff_begin)
                    if (expected.at(diff_begin) != got.at(diff_begin)) break;

                size_t diff_end{0};
                if (expected.size() and got.size()) {
                    for (; expected.size() - 1 - diff_end and got.size() - 1 - diff_end; ++diff_end) {
                        if (expected.at(expected.size() - 1 - diff_end) != got.at(got.size() - 1 - diff_end))
                            break;
                    }
                }

                auto expected_color = C(lcc::utils::Colour::Green);
                expected.insert(
                    expected.begin() + lcc::isz(diff_begin),
                    expected_color.begin(),
                    expected_color.end()
                );
                auto reset_color = C(lcc::utils::Colour::Reset);
                expected.insert(
                    expected.end() - lcc::isz(diff_end),
                    reset_color.begin(),
                    reset_color.end()
                );

                auto got_color = C(lcc::utils::Colour::Red);
                got.insert(
                    got.begin() + lcc::isz(diff_begin),
                    got_color.begin(),
                    got_color.end()
                );
                got.insert(
                    got.end() - lcc::isz(diff_end),
                    reset_color.begin(),
                    reset_color.end()
                );

                fmt::print("EXPECTED: {}\n", expected);
                fmt::print("GOT:      {}\n", got);
            }
        }

        if (option_print and passed) {
            fmt::print("  {}: {}PASS{}\n", name, C(Colour::Green), C(Colour::Reset));
        }

        return passed;
    }
};

void output_ast(std::filesystem::path p) {
    auto contents = lcc::File::Read(p);
    auto source = std::string_view{
        contents.begin(),
        contents.begin() + lcc::isz(contents.size()),
    };

    // TODO: Get target from "-t" or "--target" command line option.
    // TODO: Get format from "-f" or "--format" command line option.
    lcc::Context context{
        default_target,
        default_format,
        lcc::Context::Options{
            lcc::Context::DoNotUseColour,
            lcc::Context::DoNotPrintAST,
            lcc::Context::DoNotStopatLex,
            lcc::Context::DoNotStopatSyntax,
            lcc::Context::DoNotStopatSema,
            lcc::Context::DoNotPrintMIR,
            lcc::Context::DoNotStopatMIR //
        } //
    };

    auto mod = lcc::glint::Parser::Parse(&context, source);
    if (context.has_error()) {
        fmt::print(stderr, "ERROR: Cannot output AST matcher, error encountered during parsing\n");
        return;
    }

    // TODO: Just output un-checked ast, if asked
    {
        auto* root = mod->top_level_function()->body();
        fmt::print("Syntax:\n{}\n", langtest::print_node<lcc::glint::Expr>(root));
    }
    // Perform type-checking
    lcc::glint::Sema::Analyse(&context, *mod, true);
    if (context.has_error()) {
        fmt::print("ERROR: Cannot output AST matcher, error encountered during sema\n");
        return;
    }

    {
        auto* root = mod->top_level_function()->body();
        fmt::print("Sema:\n{}\n", langtest::print_node<lcc::glint::Expr>(root));
    }
}

void help() {
    fmt::print(
        "Glint Programming Language Test Runner\n"
        "USAGE: glinttests [FLAGS]\n"
        "FLAGS:\n"
        "  -h, --help  ::  Show this help\n"
        "  -a, --all   ::  Print messages for every test\n"
        "  -c, --count ::  Print counts at the end and for every test file processed\n"
        "  -d, --diags ::  Emit LCC Diagnostics (makes output busy)\n"
        "OPTIONS:\n"
        "  -r, --read <filepath> ::  Output the AST parsed from the given\n"
        "          source file, such that it could be used as the matcher\n"
        "          input for a test\n"
    );
}

void visit_directory(langtest::TestContext& out, std::filesystem::path directory_path, bool option_count) {
    for (const auto& entry : std::filesystem::directory_iterator(directory_path)) {
        if (entry.is_regular_file()) {
            if (option_print or option_count)
                fmt::print("{}:\n", entry.path().lexically_normal().string());

            auto count = langtest::process_ast_test_file<GlintTest>(entry.path());

            if (option_count) {
                fmt::print(
                    "  {}PASSED:  {}/{}{}\n",
                    C(lcc::utils::Colour::Green),
                    count.count_passed(),
                    count.count(),
                    C(lcc::utils::Colour::Reset)
                );
                if (count.count_failed()) {
                    fmt::print(
                        "  {}FAILED:  {}{}\n",
                        C(lcc::utils::Colour::Red),
                        count.count_failed(),
                        C(lcc::utils::Colour::Reset)
                    );
                }
            }

            out.merge(count);
        } else if (entry.is_directory()) {
            visit_directory(out, entry.path(), option_count);
        }
    }
}

int main(int argc, const char** argv) {
    bool option_count{false};
    std::filesystem::path p{""};
    for (int i = 1; i < argc; ++i) {
        std::string_view arg{argv[i]};
        if (arg.starts_with("-h") or arg.starts_with("--h") or arg.starts_with("-?")) {
            help();
            return 0;
        }
        if (arg.starts_with("-a") or arg.starts_with("--all")) {
            option_print = true;
            continue;
        }
        if (arg.starts_with("-c") or arg.starts_with("--count")) {
            option_count = true;
            continue;
        }
        if (arg.starts_with("-d") or arg.starts_with("--diag")) {
            option_suppress = false;
            continue;
        }
        if (arg.starts_with("-r") or arg.starts_with("--read")) {
            if (i + 1 >= argc) {
                fmt::print("ERROR: read option expects a source file input, but no argument was given\n");
                return 1;
            }
            ++i;
            p = argv[i];
            continue;
        }
        LCC_ASSERT(
            false,
            "Unhandled command line option `{}'.\n"
            "Use -h for more info.",
            arg
        );
    }

    if (not p.empty()) {
        if (not std::filesystem::exists(p)) {
            fmt::print("ERROR: read option given a source file input that does not correspond to an existing file!\n");
            return 1;
        }
        output_ast(p);
        return 0;
    }

    langtest::TestContext out{};

    visit_directory(out, "corpus", option_count);

    // Print stats if CLI options request it or if all tests did not pass.
    if (option_print or out.count_passed() != out.count()) {
        fmt::print(
            "STATS:\n"
            "  TESTS:   {}\n"
            "  {}PASSED:  {}{}\n"
            "  {}FAILED:  {}{}\n",
            out.count(),
            C(lcc::utils::Colour::Green),
            out.count_passed(),
            C(lcc::utils::Colour::Reset),
            C(lcc::utils::Colour::Red),
            out.count_failed(),
            C(lcc::utils::Colour::Reset)
        );
    } else {
        fmt::print(
            "~~~~~~~~~~~~~~~~~~~~~~~~\n"
            "{}    ALL TESTS PASSED: {}/{}{}\n"
            "~~~~~~~~~~~~~~~~~~~~~~~~\n",
            C(lcc::utils::Colour::Green),
            out.count(),
            out.count(),
            C(lcc::utils::Colour::Reset)
        );
    }

    return 0;
}
