* =interface='s

An =interface= expression will be a restriced form of a template expression.

The main restriction regards enforcing the /un/-expanded expression to be a type expression. This allows the compiler to know at least /something/ about the expression the template produces, like the members defined on a composite type. This means for, say, a container sort of template, the compiler knows those members exist (and possibly their type, if not part of a template parameter thing). This would ensure that, as detailed as the =interface= is, is as correct as our type checking can be within the unexpanded template body. This means that more errors in templates are caught /before/ expansion.

* =glinttools=

Separate executable for introspection of Glint programs and modules, as
well as libraries that may be used by Glint tools written in other
languages.

** =glinttools [de]mangle <identifier>=

- =<identifier>= :: A valid Glint identifier

Print the (de)mangled version of the given identifier.

Name mangling is required for function overloading, but it can make things quite messy. This would give the developer a quick way to see what the heck is going on when given a super, unreadable long name, or just to see what to search for to find the function they want.

** =glinttools diags <path>=

- =<path>= :: Filepath to Glint source

Print any diagnostics that would occur when compiling given input to LCC SSA IR.

This would catch any language errors, and would probably be ideal for a language server sort of thing.

** =glinttools types <path>=

Print a list of all types occurring within a given source

** =glinttools declarations <path>=

- =<path>= :: Filepath to Glint source

Print all declarations in a given module, along with their type (and possibly location
info). Possibly scope information as well.

** =glinttools exports <path>=

- =<path>= :: Filepath to Glint source

Print all exported declarations in a given module, along with their type (possibly location info).

** =glinttools cmake <path>=

- =<path>= :: Filepath to Glint source

Attempt to generate a valid =CMakeLists.txt= that builds the given Glint file in the current working directory.

Should make something like the following...
#+begin_src cmake
# Yes, you will need to change this to wherever you have LCC installed.
# Alternatively, you could just copy the .cmake toolchain files provided
# with LCC alone: the entire compiler isn't needed.
set(
  LCC_PATH
  "~/Programming/play/LensorCompilerCollection"
  CACHE FILEPATH
  "Path to the Lensor Compiler Collection (LCC) on your system.
If you don't have LCC yet, you can get it at https://github.com/LensPlaysGames/LensorCompilerCollection"
)

if(NOT EXISTS ${LCC_PATH})
  message(
    FATAL_ERROR
    "LCC_PATH does not exist; you probably need to set this CMake option to wherever you have LCC installed.
If you don't have LCC yet, you can get it as part of the Glint Standard Library at https://github.com/LensPlaysGames/GlintStandardLibrary
LCC_PATH: ${LCC_PATH}"
  )
endif()

list(APPEND CMAKE_MODULE_PATH "${LCC_PATH}/cmake")

cmake_minimum_required(VERSION 3.24)
project(glinttools_autogenerated LANGUAGES Glint)

add_executable(autogenerated)
target_add_sources(autogenerated <path>)

# Download and build Glint Standard Library as part of build.
include(FetchContent)
set(FETCHCONTENT_QUIET OFF)
set(FETCHCONTENT_UPDATES_DISCONNECTED ON)
# NOTE: If you don't like cloning every time you configure a new build
# tree, you can specify `libgstd_SOURCE_DIR` as pointing to the cloned
# repo.
FetchContent_Declare(
    libgstd
    GIT_REPOSITORY https://github.com/LensPlaysGames/GlintStandardLibrary.git
    GIT_TAG origin/main
    SOURCE_DIR "${CMAKE_CURRENT_BINARY_DIR}/libs/libgstd"
)
FetchContent_MakeAvailable(libgstd)
target_include_directories(autogenerated PUBLIC ${fmtlib_SOURCE_DIR}/include)

# Link against Glint Standard Library.
target_link_libraries(autogenerated PUBLIC libgstd)
#+end_src

* Enum Subsets

Have a big enum with lots of values? Want a function to operate on only a subset of those values? This is where enum subsets come in. Not for when you want to compose multiple enums, but for when you want to decompose a single into multiple.

The idea is, an enum subset will give a list of identifiers that must be present in the enum it is a subset of, and initialisers are disallowed. It is purely so, for example, a function could convert only =*==, =+==, etc. into their non-assignment counterparts =*= and =+=, without having to handle every enum value as a possibility.

* <Development Aid> Tests Recall

Basically, when you run =glinttests=, save the results. If old results are found, show comparison between old results and new results (i.e. "this test is NOW FAILING").
