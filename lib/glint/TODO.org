* Recursive Data

A binary tree data structure. How to do this in Glint?

* NULL, nil, or something like that.

How can I both assign something to nothing, as well as check against the presence of something.

* =-= as identifier continuation character?

That way =foo-bar= would be a valid identifier. I just kind of like how it looks vs snake case. Modules could have fun with this and do =category-thing--detail= style naming.

* Dependencies...

A imports B imports C
A imports C

* Multiple Import Levels

A imports B imports C

* =import foo as bar=

Given an identifer, only allow acessing the module's exports by accessing members of the identifier using =.= (i.e. =bar.x=).

Without =as bar=, the exports of the module are accessible in the top level scope.

* Make Consistent the Type Declarations

Currently, it's a bit confusing when something is a value vs when something is a type.

#+begin_src glint
  bar : struct { x : int; y : int; };

  ;; Is this valid??
  foo : bar;
  ;; Or this??
  bar.x := 69;
#+end_src

Basically, the syntax for type declarations is exactly the same as variable declarations, at the moment, and that kind of gets a bit confusing in my opinion.

#+begin_src glint
  ;; Verbose, yet clear that bar is a type.
  bar : type = struct { x : int; y : int; };
  ;; Shorter, still kind of messy with three colons (two for type inferred
  ;; declaration, one to begin explicit type expression).
  bar ::: struct { x : int; y : int };

  foo : bar;
#+end_src

#+begin_src glint
  bar ::: struct { x : int; y : int; };
  blah ::: bar;
#+end_src

So, the triple colon doesn't SUPER bother me. It's "good enough", I guess.

So, I think we are saying that =:= as a binary operator ONLY EVER declares a VARIABLE. It has an actual value that isn't the type it's declared as. So, =t : type = <type>= is valid because =t= has a value that is some type expression, but it's type is =type=. Whereas a named type/type alias would not be valid in that form (i.e. =t : <type>;=), since =t= would have no value that isn't the type it is declared as being.

In conclusion:
- =lhs : rhs= declares the lhs as being A VALUE named lhs of TYPE rhs. The (only) way to get =rhs= from =lhs= is via =typeof=. CURRENTLY STRUCT, ENUM, UNION, AND SUM DECLARATIONS BREAK THIS CONVENTION.
- =lhs ï»¿:: rhs= declares the lhs as being a VALUE named lhs EQUAL to rhs. The (only) way to get =rhs= from =lhs= is via referencing the name.

And, what about aliases? We currently have NO syntax for type aliases...

* =interface='s

An =interface= expression will be a restriced form of a template expression.

The main restriction regards enforcing the /un/-expanded expression to be a type expression. This allows the compiler to know at least /something/ about the expression the template produces, like the members defined on a composite type. This means for, say, a container sort of template, the compiler knows those members exist (and possibly their type, if not part of a template parameter thing). This would ensure that, as detailed as the =interface= is, is as correct as our type checking can be within the unexpanded template body. This means that more errors in templates are caught /before/ expansion.

* =mapf=

Apply each argument expression to a given function.

* =maps_arguments= function attribute

If a function =maps_arguments=, then, it will accept any non-zero amount of arguments, and pass each to a separate call of itself.

#+begin_src glint
  ;; ERROR! function with maps_arguments attribute must receive non-zero amount of arguments.
  foo : void() maps_arguments {}

  foo : void(x : int) maps_arguments {
    print x - 1;
  }
  foo : void(x : byte) maps_arguments {
    print x + 69;
  }

  ;; Turns into =mapf foo 24, 69, `4`=. Which turns into =foo 24; foo 69; foo `4`;=
  foo 24, 69, `4`;
#+end_src

There should probably be error cases for the following:
- Not all functions in an overload have =maps_arguments= attribute.
- Not all functions in an overload with =maps_arguments= attribute have the same amount of arguments. (potentially changes in the future, if we want to try matching the longest overload first and keep going until we get one).

* (Optional Compiler Feature/Extension) Allow Override of runtime dynamic array oob access handler.

By default, it basically just does =std::exit(1)=, and that's not always useful for a user. We should allow the user to define overrides of these handlers, if they want.

Basically, sema would look for a specific function name (i.e. =__oob_access=), ensure a specific signature, and then insert a call to that function whenever it generates it's oob access handler (but only if the function exists). It would still call =std::exit(1)= after the custom handler is invoked, just in case.

Also an oom_handler that we will insert calls to with the return value of malloc.

* Module Partitions

Basically, partitions will be a way to open up a named scope without any extra semantics.

* =glinttools=

Separate executable for introspection of Glint programs and modules, as
well as libraries that may be used by Glint tools written in other
languages.

** =glinttools demangle <identifier>=

- =<identifier>= :: A mangled Glint identifier (=_XGlint...=)

Print the demangled version of the given identifier.

Name mangling is required for function overloading, but it can make things quite messy. This would give the developer a quick way to see what the heck is going on when given a super long, unreadable name.

** =glinttools showmeta <path>=

- =<path>= :: Filepath to Glint module metadata (or built module artifact)

Extract the information from the given module metadata and print it to the user.

** =glinttools diags <path>=

- =<path>= :: Filepath to Glint source

Print any diagnostics that would occur when compiling given input to LCC SSA IR.

This would catch any language errors, and would probably be ideal for a language server sort of thing.

** =glinttools types <path>=

Print a list of all types occurring within a given source

** =glinttools declarations <path>=

- =<path>= :: Filepath to Glint source

Print all declarations in a given module, along with their type (and possibly location
info). Possibly scope information as well.

** =glinttools exports <path>=

- =<path>= :: Filepath to Glint source

Print all exported declarations in a given module, along with their type (possibly location info).

** =glinttools cmake <path>=

- =<path>= :: Filepath to Glint source

Attempt to generate a valid =CMakeLists.txt= that builds the given Glint file in the current working directory.

Should make something like the following...
#+begin_src cmake
  # Yes, you will need to change this to wherever you have LCC installed.
  # Alternatively, you could just copy the .cmake toolchain files provided
  # with LCC alone: the entire compiler isn't needed.
  #
  # Alternatively, we could use rely on FetchContent...
  set(
    LCC_PATH
    "~/Programming/play/LensorCompilerCollection"
    CACHE FILEPATH
    "Path to the Lensor Compiler Collection (LCC) on your system.
  If you don't have LCC yet, you can get it at https://github.com/LensPlaysGames/LensorCompilerCollection"
  )

  if(NOT EXISTS ${LCC_PATH})
    message(
      FATAL_ERROR
      "LCC_PATH does not exist; you probably need to set this CMake option to wherever you have LCC installed.
  If you don't have LCC yet, you can get it as part of the Glint Standard Library at https://github.com/LensPlaysGames/GlintStandardLibrary
  LCC_PATH: ${LCC_PATH}"
    )
  endif()

  list(APPEND CMAKE_MODULE_PATH "${LCC_PATH}/cmake")

  cmake_minimum_required(VERSION 3.24)
  project(glinttools_autogenerated LANGUAGES Glint)

  add_executable(autogenerated)
  target_add_sources(autogenerated <path>)

  # Download and build Glint Standard Library as part of build.
  include(FetchContent)
  set(FETCHCONTENT_QUIET OFF)
  set(FETCHCONTENT_UPDATES_DISCONNECTED ON)
  # NOTE: If you don't like cloning every time you configure a new build
  # tree, you can specify `libgstd_SOURCE_DIR` as pointing to the cloned
  # repo.
  FetchContent_Declare(
      libgstd
      GIT_REPOSITORY https://github.com/LensPlaysGames/GlintStandardLibrary.git
      GIT_TAG origin/main
      SOURCE_DIR "${CMAKE_CURRENT_BINARY_DIR}/libs/libgstd"
  )
  FetchContent_MakeAvailable(libgstd)
  target_include_directories(autogenerated PUBLIC ${fmtlib_SOURCE_DIR}/include)

  # Link against Glint Standard Library.
  target_link_libraries(autogenerated PUBLIC libgstd)
#+end_src

* Recursive Lambda

Can a lambda call itself?

* Enum Subsets

Have a big enum with lots of values? Want a function to operate on only a subset of those values? This is where enum subsets come in. Not for when you want to compose multiple enums, but for when you want to decompose a single into multiple.

The idea is, an enum subset will give a list of identifiers that must be present in the enum it is a subset of, and initialisers are disallowed. It is purely so, for example, a function could convert only =*==, =+==, etc. into their non-assignment counterparts =*= and =+=, without having to handle every enum value as a possibility.

* <Development Aid> Tests Recall

Basically, when you run =glinttests=, save the results. If old results are found, show comparison between old results and new results (i.e. "this test is NOW FAILING").
