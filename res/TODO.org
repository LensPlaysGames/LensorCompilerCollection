# -*- mode: org ; eval: (olivetti-mode 1) -*-

* LCC

- [IRTest]: IR -> IR testing facility
  This will allow us to test optimisations, as well as make sure our IR parser is a working frontend (further than runtest).
  We could also re-use the IR against IR matching code for LangTest's IR facilities.
- [Register Allocation]: Register classes (floats/scalar)
  Unspecified and float

  [[https://my.eng.utah.edu/~cs4400/sse-fp.pdf][Relevant Edu Doc]]

  I may just use "regular" Register operands and have special instructions that "treats" register operands as float registers... I dunno. I guess I need /some/ way of telling the register allocator to allocate certain registers...

- [Meta]: Move IR optimisations to their own library
  I want =libopt= to be a library LCC uses that operates on LCC IR; that way, other programs may be able to re-use the optimisations if they choose to target LCC IR (without having to use our driver).
- [Meta]: Move LCC IR to it's own library (in it's own folder under =lib/=)
  Also move LCC IR Parser to a proper frontend (in it's own folder under =lib/=)

  Basically, we currently have "LCC" as a monolithic library. I dislike it.
  I want LCC to be broken into LCC IR (declaration, creation, module, etc), LCC IR Optimisations (IR -> IR transformations), and LCC Core (context, utilities, file opening, etc).

  #+begin_example
  LCC IR               depends on LCC CORE
  LCC IR Optimisations depends on LCC IR
  LCC IR Frontend      depends on LCC IR
  #+end_example

- [Register Allocation]: ISel should mark call instructions as clobbering a unique "volatile registers" register (similar to return register), such that RA knows whats up, and could even insert spills before and after the call if necessary.
- [Test]: Convert old opt tests in =tst/= into IR tests.
- [Backend/WASM]: Struct and array types
  WebAssembly 3.0 has composite types, =struct= and =array=.
  They need a bit of special handling, so it will be quite an extensive feature to implement (requiring overrides for storing and loading, variable initialisation, and more).
- [Emscripten]: Automatically install =res/lcc.svg=
- [Driver]: =-gcc= compatibility layer: args after are parsed as GCC arguments
- [Driver]: =--color-theme <file>= option to remap ANSI/VT100 emitted terminal codes to different colors (i.e. BoldRed -> Green) if you want green errors for some reason.

* Glint

- [Parser/Sema]: =embed "path";= -> string literal of file contents
- [Cereal]: Flesh out binary AST format
- [Parser/Sema]: Switch on value
- [Sema]: Fix deproceduring of one side of binary operation: =foo : int() 69; foo + 27;=
- [Parser/Sema]: =T.bits=, =T.bytes=, =T.align=, =T_enum.count=
- [Sema]: =maps_arguments= function attribute
- [Parser/Sema]: Module versioning

  Require MAJOR.MINOR.PATCH version in module declaration.
  Require MAJOR.MINOR.PATCH version during module import.

  The idea is, the "package.json" of Glint should be the file header. It should contain the declaration of the "package", as well as dependencies, including versions.
- [Parser/Sema]: Unary operator (keyword) for asserting compile time evaluation
  =evaluate=?
  "evaluate 42 + 27" -> "69".
- [Parser]: Warn when multiple expressions appear on one line
  Multiple "top level" expressions.
- [Parser/Sema]: Compile-time Checked Interpolation: =printf "value: {}\n", 69;=
  This won't be different from =print=, I just like this style of doing
  things (and a lot of people tend to prefer it over splitting strings).
  This will lower into a =print= call, splitting the format string into
  relevant string literals (split on `{}`).

  Also =println=, which just adds a byte literal =\n= as a final argument.
- [Sema]: Include an =int= formatter function, so that people can write =print 420=, and it "just works".
- [Sema]: =out;= as first expression of function body becomes declaration of return type
  Or maybe behind a =builds_result= attribute, where =result= is then automagically declared as a variable of the return type.
- [Meta]: glintlang website
  Probably a GitHub organisation with a GitHub Pages website.
  Site generated from Org and org-publish or something like that.
- [Sema]: Use intrinsic memset for initialisation (optimisation)
  I just used an external memset because that seemed easier at the time. I think the word intrinsic scared (scares?) me.
- [Sema]: Variable Entanglement
  Tell the compiler that if a variable =A= has a known value (or a range of values), then variable =B= has a known value (or a range of values).
  The compiler would be able to optimise more in certain cases if it knew more about how values were related to each other (if they are).
- [Sema]: Dynamic array of =expr=. =for e in exprs, apply foo, e;= type of thing.
- [Parser/Sema]: Tokens in the AST
  Basically, if we could have a dynamic array of =token=, we could then insert that into the source code via some special token list application operator... This would let Glint code build Glint code at compile time (like a LISP macro operating on symbols themselves vs the values they are bound to).
- [Diags]: Get rid of "Miscellaneous" ErrorId
- [Lexer]: Case Insensitivity
  Behind =---case-insensitive= flag?
  Or =---case-sensitive=?
- [Parser/Sema]: Recursive Lambda
- [Parser/Sema]: Named scopes
- [Module]: =---ast-binary= to emit binary representation of AST

  My thought is that a build system could hash the AST instead of the source, so that trivial changes in whitespace or formatting would not actually cause an invalidation.

  In this same vein, =---ast-langtest= to get the LISP-like AST output used in LangTest.
- [Meta]: Fix abuse of =ast.hh=

  It's just far too far-reaching, all-encompassing.

  Ideally, we'd /at least/ separate the definitions of the "base" types (Expr, Type, Loop) and the "final" types (ReturnExpr, etc).
- [Sema]: =---no-default-handlers=
  If passed, do not include definitions for the functionality that Sema generates calls to, for example (i.e. =__dynarray_grow=).
- [Lexer]: Disallow =_X= anywhere in identifiers (for mangled name compatibility)

* LangTest

- [Deduplication]: Better facilities for parsing lang tests.
- [LangTest]: fail test specifier given an expected error id in brackets
  i.e. =:fail_sema["invalid-literal/integer"]= or something to make sure the /expected/ diagnostic is emitted, not just a similar one.
- Write an IR LangTest implementation.

* RunTest

- [Glint] Delete generated gmeta files
  We should probably just delete all of them in the directory after we are done, or something (rather than try to delete each one as it's generated, like we do with other artifacts).
