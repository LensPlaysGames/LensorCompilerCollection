- Urgent
  - [x] Fix Register Allocation Instruction Interference algorithm. It is currently based on traversing dominator trees, which makes no sense for RA. We should instead iterate backwards over blocks, starting at exit, until we reach the entrance...
    "Iff A is reachable from B, then all live values at the beginning of A must continue to stay live all the way through B" <- currently not upheld due to dominator tree traversal.
- [ ] Miscellany.
  - [x] Operator `as`.
  - [x] Vector macros should be snake_case.
  - [ ] LLVM_PATH env var or something in CMakeLists.txt rather than `find_package()`?
  - [x] `integer`/`byte`/`void` should be keywords (and terminals in the grammar).
  - [x] `s8/u8/s16/u16/s32/u32/s64/u64`
    - [ ] Properly support arbitrarily-sized integer arithmetic; i.e. 18-bit addition overflow and such
  - [ ] Early `return`
    - [ ] Parsing
    - [ ] Return block in the IR
  - [ ] Types as values using the `&` operator. (requires `Structs`)
  - [ ] Function bodies must be blocks or preceded by `=`.
  - [ ] `ext` functions may have a body?
  - [ ] Add `export` and make top-level variables local and top-level functions internal by default.
  - [x] Add a `[[nomangle]]` attribute (requires attributes).
  - [ ] Rename `ext` to `extern` and make it syntactic sugar for `export [[nomangle]]`
  - [ ] Implicit cast sema pass: `a + b` where `a` is a `byte` and `b` an `integer` -> `(a as integer) + b`
  - [ ] Testing Framework: Add ability to only show failing tests
  - [ ] `x as void` used to discard `x`
  - [ ] Resolve the two different kinds of array-type loading: entire copy vs pointer decay. Basically, `foo[2]` needs `foo` to be loaded as a pointer. `a : foo[2] = b` requires loading entire copy of `b` into `a`.
  - [ ] Add multiline comment syntax
  - [ ] Some syntax to repeat a string literal X amount of times, and another to ensure minimum size of string literal
  - [ ] It prints "unknown symbol" even for mismatched overload that should have pretty error
  - [ ] Change name of LINUX calling convention; it's actually just SystemV
  - [ ] MSWIN x64 calling convention for non-aggregate arguments on the stack isn't properly handled
- [ ] Optimisation
  - [x] Zero subscript still does add/multiply when it doesn't need to
  - [x] Zero member access still does add when it doesn't need to, afaik
  - [ ] Inline small functions?
- x86_64
  - [ ] Pad string literals to ensure alignment of statics
- [ ] Attributes
  - [x] Parsing  "[[noreturn]]" or "=[noreturn]" or "attr noreturn"
  - [ ] noreturn
  - [ ] discardable (kind of opposite of nodiscard, the default)
    - [ ] Make "no discard" the default for all non-void returning functions.
  - [ ] maybe_unused
  - [ ] deprecated
  - [ ] deprecated("reason")
  - [ ] call_once
- [ ] Pragmas
  - [ ] Parsing
  - [ ] `pragma mangling [on|off]`
- [ ] Function Overloading
  - [x] Overloading terminology
  - [x] Overload tests
  - [x] Custom printf w/ `%T` for types etc.
  - [x] Proper error reporting for overloading.
  - [x] Fix the `sym->type`, `sym->node->type` nonsense
  - [x] Name mangling.
  - [x] No mangling for `ext` declarations.
  - [ ] Reenable checking for duplicate declarations.
    - [ ] Check for duplicate vars
    - [ ] Check for function redeclarations
    - [x] Disallow overloading on the return value.
      - [ ] This is done, however it is only done **when a function is resolved**. This means unused functions go unchecked.
  - [ ] Proper checking for incomplete types in the parser.
- [ ] Types in the IR
  - [x] Byte type
  - [x] Type info in codegen/IR.
  - [ ] Backend: Handle size/alignment requirements
  - [x] Use eax, ax, al, etc.
  - [x] Actually implementing casts.
    - [x] During codegen, we should actually output `zext`/`sext` if needed. Otherwise truncation is automatic.
  - [ ] Update IR parser
  - [x] Operators (unary and binary) need to pick return type instead of strictly returning `integer`
  - [ ] Add a semantic analysis/type-checking pass over the IR, after lowering (ensure backend doesn't mess up)
- [ ] Arrays
  - [x] Semantic analysis for static arrays.
  - [x] Codegen
  - [x] How do we implement reassigning arrays? Libc `memcpy()` or some builtin variant?
    - [x] Use compiler explorer to see how GCC does it for ‘inspiration’.
  - [x] Arrays as function parameters.
    - [x] Currently, only register-based parameters are really supported; we need to implement stack parameters for non-integer types.
  - [ ] Returning arrays from functions.
- [ ] Slices / dynamic arrays.
  - [ ] Parsing/AST.
  - [ ] Semantic analysis.
    - [ ] Implicit creation from static arrays
  - [ ] Codegen.
  - [ ] Length operator: `#`
  - [ ] Subscripting
- [x] Strings
  - [x] Parsing string literals.
  - [x] Codegen.
  - [x] Backend.
- [ ] Structs
  - [ ] Order-independent types.
  - [x] Structs in the AST.
  - [x] Struct declarations.
  - [x] Semantic analysis for structs.
  - [x] Codegen for structs.
  - [x] `type` keyword in the parser/grammar.
  - [ ] Make sure nested structs work.
  - [ ] Arbitrary compile-time struct literals.
    - [ ] Syntax? Maybe "[]" just like arrays.
  - [x] Structs as parameters.
  - [ ] Structs as return values.
- [ ] Modules.
  - [ ] `module <identifier>` declaration.
  - [ ] Emitting module metadata.
  - [ ] Loading module metadata.
  - [ ] `export` (Pragma or sth. to export everything?)
  - [ ] `import`
  - [ ] Module initialisation.
  - [ ] Putting it all together.
