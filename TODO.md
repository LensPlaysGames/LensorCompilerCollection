- [ ] Miscellany.
  - [x] Operator `as`.
  - [x] Vector macros should be snake_case.
  - [ ] LLVM_PATH env var or something in CMakeLists.txt rather than `find_package()`?
  - [ ] `integer`/`byte`/`void` should be keywords (and terminals in the grammar).
  - [ ] Early `return`
    - [ ] Parsing
    - [ ] Return block in the IR
  - [ ] Types as values using the `&` operator. (requires `Structs`)
  - [ ] Function bodies must be blocks or preceded by `=`.
  - [ ] `ext` functions may have a body.
  - [ ] Implicit cast sema pass: `a + b` where `a` is a `byte` and `b` an `integer` -> `(a as integer) + b`
  - [ ] Testing Framework: Add ability to only show failing tests
  - [ ] `x as void` used to discard `x`
  - [ ] Resolve the two different kinds of array-type loading: entire copy vs pointer decay. Basically, `foo[2]` needs `foo` to be loaded as a pointer. `a : foo[2] = b` requires loading entire copy of `b` into `a`.
  - [ ] Add multiline comment syntax
- [ ] Optimisation
  - [ ] Zero subscript still does add/multiply when it doesn't need to
- [ ] Attributes
  - [ ] Parsing
  - [ ] `[[noreturn]]`
  - [ ] `[[discardable]]`
    - [ ] Make "no discard" the default for all non-void returning functions.
  - [ ] `[[maybe_unused]]`
  - [ ] `[[deprecated]]`
  - [ ] `[[deprecated("reason")]]`
  - [ ] `[[call_once]]`
- [ ] Pragmas
  - [ ] Parsing
  - [ ] `pragma mangling [on|off]`
- [ ] Function Overloading
  - [x] Overloading terminology
  - [x] Overload tests
  - [x] Custom printf w/ `%T` for types etc.
  - [x] Proper error reporting for overloading.
  - [x] Fix the `sym->type`, `sym->node->type` nonsense
  - [x] Name mangling.
  - [x] No mangling for `ext` declarations.
  - [ ] Reenable checking for duplicate declarations.
    - [ ] Check for duplicate vars
    - [ ] Check for function redeclarations
    - [x] Disallow overloading on the return value.
      - [ ] This is done, however it is only done **when a function is resolved**. This means unused functions go unchecked.
  - [ ] Proper checking for incomplete types in the parser.
- [ ] Types in the IR
  - [x] Byte type
  - [x] Type info in codegen/IR.
  - [ ] Backend: Handle size/alignment requirements
  - [x] Use eax, ax, al, etc.
  - [ ] Actually implementing casts.
    - [ ] During codegen, we should actually output `zext`/`sext` if needed. Otherwise truncation is automatic.
  - [ ] Update IR parser
  - [ ] Operators (unary and binary) need to pick return type instead of strictly returning `integer`
- [ ] Arrays
  - [ ] Semantic analysis for static arrays.
  - [ ] Codegen
  - [ ] How do we implement reassigning arrays? Libc `memcpy()` or some builtin variant?
    - [ ] Use compiler explorer to see how GCC does it for ‘inspiration’.
  - [ ] Arrays as function parameters.
  - [ ] Returning arrays from functions.
- [ ] Slices / dynamic arrays.
  - [ ] Parsing/AST.
  - [ ] Semantic analysis.
    - [ ] Implicit creation from static arrays
  - [ ] Codegen.
  - [ ] Length operator: `#`
  - [ ] Subscripting
- [ ] Strings
  - [x] Parsing string literals.
  - [ ] Codegen.
  - [ ] Backend.
- [ ] Structs
  - [ ] Order-independent types.
  - [ ] Structs in the AST.
  - [ ] Struct declarations.
  - [ ] Semantic analysis for structs.
  - [ ] Codegen for structs.
  - [ ] `type` keyword in the parser/grammar.
  - [ ] Make sure nested structs work.
  - [ ] Arbitrary compile-time struct literals.
    - [ ] Syntax?
  - [ ] Structs as parameters.
  - [ ] Structs as return values.
- [ ] Modules.
  - [ ] `module` declaration.
  - [ ] Emitting module metadata.
  - [ ] Loading module metadata.
  - [ ] `export` (Pragma or sth. to export everything?)
  - [ ] `import`
  - [ ] Module initialisation.
  - [ ] Putting it all together.
