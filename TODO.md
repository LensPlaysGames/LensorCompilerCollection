- Urgent
  - [ ] Fix Register Allocation Instruction Interference algorithm. It is currently based on traversing dominator trees, which makes no sense for RA. We should instead iterate backwards over blocks, starting at exit, until we reach the entrance...
    "Iff A is reachable from B, then all live values at the beginning of A must continue to stay live all the way through B" <- currently not upheld due to dominator tree traversal.
- [ ] Miscellany.
  - [x] Operator `as`.
  - [x] Vector macros should be snake_case.
  - [ ] LLVM_PATH env var or something in CMakeLists.txt rather than `find_package()`?
  - [ ] `integer`/`byte`/`void` should be keywords (and terminals in the grammar).
  - [ ] Early `return`
    - [ ] Parsing
    - [ ] Return block in the IR
  - [ ] Types as values using the `&` operator. (requires `Structs`)
  - [ ] Function bodies must be blocks or preceded by `=`.
  - [ ] `ext` functions may have a body?
  - [ ] Add `export` and make top-level variables local and top-level functions internal by default.
  - [ ] Add a `[[nomangle]]` attribute (requires attributes).
  - [ ] Rename `ext` to `extern` and make it syntactic sugar for `export [[nomangle]]`
  - [ ] Implicit cast sema pass: `a + b` where `a` is a `byte` and `b` an `integer` -> `(a as integer) + b`
  - [ ] Testing Framework: Add ability to only show failing tests
  - [ ] `x as void` used to discard `x`
  - [ ] Resolve the two different kinds of array-type loading: entire copy vs pointer decay. Basically, `foo[2]` needs `foo` to be loaded as a pointer. `a : foo[2] = b` requires loading entire copy of `b` into `a`.
  - [ ] Add multiline comment syntax
- [ ] Optimisation
  - [ ] Zero subscript still does add/multiply when it doesn't need to
- [ ] Attributes
  - [ ] Parsing
  - [ ] `[[noreturn]]`
  - [ ] `[[discardable]]`
    - [ ] Make "no discard" the default for all non-void returning functions.
  - [ ] `[[maybe_unused]]`
  - [ ] `[[deprecated]]`
  - [ ] `[[deprecated("reason")]]`
  - [ ] `[[call_once]]`
- [ ] Pragmas
  - [ ] Parsing
  - [ ] `pragma mangling [on|off]`
- [ ] Function Overloading
  - [x] Overloading terminology
  - [x] Overload tests
  - [x] Custom printf w/ `%T` for types etc.
  - [x] Proper error reporting for overloading.
  - [x] Fix the `sym->type`, `sym->node->type` nonsense
  - [x] Name mangling.
  - [x] No mangling for `ext` declarations.
  - [ ] Reenable checking for duplicate declarations.
    - [ ] Check for duplicate vars
    - [ ] Check for function redeclarations
    - [x] Disallow overloading on the return value.
      - [ ] This is done, however it is only done **when a function is resolved**. This means unused functions go unchecked.
  - [ ] Proper checking for incomplete types in the parser.
- [ ] Types in the IR
  - [x] Byte type
  - [x] Type info in codegen/IR.
  - [ ] Backend: Handle size/alignment requirements
  - [x] Use eax, ax, al, etc.
  - [ ] Actually implementing casts.
    - [ ] During codegen, we should actually output `zext`/`sext` if needed. Otherwise truncation is automatic.
  - [ ] Update IR parser
  - [ ] Operators (unary and binary) need to pick return type instead of strictly returning `integer`
- [ ] Arrays
  - [ ] Semantic analysis for static arrays.
  - [ ] Codegen
  - [ ] How do we implement reassigning arrays? Libc `memcpy()` or some builtin variant?
    - [ ] Use compiler explorer to see how GCC does it for ‘inspiration’.
  - [ ] Arrays as function parameters.
    - [ ] Currently, only register-based parameters are really supported; we need to implement stack parameters for non-integer types.
  - [ ] Returning arrays from functions.
- [ ] Slices / dynamic arrays.
  - [ ] Parsing/AST.
  - [ ] Semantic analysis.
    - [ ] Implicit creation from static arrays
  - [ ] Codegen.
  - [ ] Length operator: `#`
  - [ ] Subscripting
- [ ] Strings
  - [x] Parsing string literals.
  - [x] Codegen.
  - [x] Backend.
- [ ] Structs
  - [ ] Order-independent types.
  - [ ] Structs in the AST.
  - [ ] Struct declarations.
  - [ ] Semantic analysis for structs.
  - [ ] Codegen for structs.
  - [ ] `type` keyword in the parser/grammar.
  - [ ] Make sure nested structs work.
  - [ ] Arbitrary compile-time struct literals.
    - [ ] Syntax?
  - [ ] Structs as parameters.
  - [ ] Structs as return values.
- [ ] Modules.
  - [ ] `module` declaration.
  - [ ] Emitting module metadata.
  - [ ] Loading module metadata.
  - [ ] `export` (Pragma or sth. to export everything?)
  - [ ] `import`
  - [ ] Module initialisation.
  - [ ] Putting it all together.
