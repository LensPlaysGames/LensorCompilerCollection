# -*- mode: org ; eval: (olivetti-mode 1) -*-

* LCC

- [IRTest]: IR -> IR testing facility
  This will allow us to test optimisations, as well as make sure our IR parser is a working frontend (further than runtest).
  We could also re-use the IR against IR matching code for LangTest's IR facilities.
- [MIRTest]: MIR -> MIR testing facility
  This will allow us to test register allocation, instruction selection, among other things.
- [Test Coverage]: floats
  - LCC IR float lexing/parsing
  - float return value register allocation
- [Meta]: Move IR optimisations to their own library
  I want =libopt= to be a library LCC uses that operates on LCC IR; that way, other programs may be able to re-use the optimisations if they choose to target LCC IR (without having to use our driver).
- [Meta]: Move LCC IR to it's own library (in it's own folder under =lib/=)
  Also move LCC IR Parser to a proper frontend (in it's own folder under =lib/=)

  Basically, we currently have "LCC" as a monolithic library. I dislike it.
  I want LCC to be broken into LCC IR (declaration, creation, module, etc), LCC IR Optimisations (IR -> IR transformations), and LCC Core (context, utilities, file opening, etc).

  #+begin_example
  LCC IR               depends on LCC CORE
  LCC IR Optimisations depends on LCC IR
  LCC IR Frontend      depends on LCC IR
  #+end_example

- [Test]: Convert old opt tests in =tst/= into IR tests.
- [Fractionals]: deconstruct binary32/64 to sign, exponent, and mantissa

  Also helpers to:
  - Construct binary32/64 from sign, exponent, and mantissa
  - Normalize mantissa, adjusting exponent


- [Output]: Debug output for MIR
  Basically, generalised IR ("fresh" MIR) is three address code. The problem is that a lot of machines in real life are two address code, and the destination register is one of the operands (in GNU style, the last/second).
  I want to be able to print MIR without having the "result register" printed when the machine that the code the MIR is representing has no notion of that.
- [Backend/WASM]: Struct and array types
  WebAssembly 3.0 has composite types, =struct= and =array=.
  They need a bit of special handling, so it will be quite an extensive feature to implement (requiring overrides for storing and loading, variable initialisation, and more).
- [Driver]: =-gcc= compatibility layer: args after are parsed as GCC arguments
- [Driver]: =--color-theme <file>= option to remap ANSI/VT100 emitted terminal codes to different colors (i.e. BoldRed -> Green) if you want green errors for some reason.
- [Register Allocation]: Use liveness data to spill less volatile registers across calls
  This will require saving a snapshot of the live values after certain instructions (call instructions) such that we know the virtual registers that were live, and then, once we have colored virtual registers in with hardware ones, we can know which of those interfering virtual registers ended up in a volatile register, and we know we have to save it. If it doesn't appear in the snapshot, it doesn't need to be preserved.

* Glint

- [QoL]: Ability to iterate a container you are editing while iterating it
  #+begin_src glint
    for x in container, {
      if x.value,
        container[x.value] += !{ ... }; ;; (!) This should _NOT_ segfault the next loop iteration
    };
  #+end_src
  Basically, if we are looping over a container, and it is modified, we need to adjust the loop code to take that into account. Ideally, we would update the "current" iterator reference (=x= in the above example) after every modification that requires it (possible resize).
- [Control Flow]: =continue=, =break=
  Possibly even named loops and the ability to break/continue from specific ones from nested loops...
- [Parser/Sema]: Named scopes
- [Parser/Sema]: =embed "path";= -> string literal of file contents
- [Cereal]: Flesh out binary AST format
- [Parser/Sema]: Switch on value
- [Sema]: Fix deproceduring of one side of binary operation: =foo : int() 69; foo + 27;=
- [Parser/Sema]: =T.bits=, =T.bytes=, =T.align=, =T_enum.count=
- [Sema]: =maps_arguments= function attribute
- [Parser/Sema]: Module versioning

  Require MAJOR.MINOR.PATCH version in module declaration.
  Require MAJOR.MINOR.PATCH version during module import.

  The idea is, the "package.json" of Glint should be the file header. It should contain the declaration of the "package", as well as dependencies, including versions.
- [Parser/Sema]: Unary operator (keyword) for asserting compile time evaluation
  =evaluate=?
  "evaluate 42 + 27" -> "69".
- [Parser]: Warn when multiple expressions appear on one line
  Multiple "top level" expressions.
- [Parser/Sema]: Compile-time Checked Interpolation: =printf "value: {}\n", 69;=
  This won't be different from =print=, I just like this style of doing
  things (and a lot of people tend to prefer it over splitting strings).
  This will lower into a =print= call, splitting the format string into
  relevant string literals (split on `{}`).

  Also =println=, which just adds a byte literal =\n= as a final argument.
- [Sema]: Include an =int= formatter function, so that people can write =print 420=, and it "just works".
- [Sema]: =out;= as first expression of function body becomes declaration of return type
  Or maybe behind a =builds_result= attribute, where =result= is then automagically declared as a variable of the return type.
- [Meta]: glintlang website
  Probably a GitHub organisation with a GitHub Pages website.
  Site generated from Org and org-publish or something like that.
- [Sema]: Use intrinsic memset for initialisation (optimisation)
  I just used an external memset because that seemed easier at the time. I think the word intrinsic scared (scares?) me.
- [Sema]: Variable Entanglement
  Tell the compiler that if a variable =A= has a known value (or a range of values), then variable =B= has a known value (or a range of values).
  The compiler would be able to optimise more in certain cases if it knew more about how values were related to each other (if they are).
- [Sema]: Dynamic array of =expr=. =for e in exprs, apply foo, e;= type of thing.
- [Parser/Sema]: Tokens in the AST
  Basically, if we could have a dynamic array of =token=, we could then insert that into the source code via some special token list application operator... This would let Glint code build Glint code at compile time (like a LISP macro operating on symbols themselves vs the values they are bound to).
- [Diags]: Get rid of "Miscellaneous" ErrorId
- [Lexer]: Case Insensitivity
  Behind =---case-insensitive= flag?
  Or =---case-sensitive=?
- [Parser/Sema]: Recursive Lambda
- [Module]: =---ast-binary= to emit binary representation of AST

  My thought is that a build system could hash the AST instead of the source, so that trivial changes in whitespace or formatting would not actually cause an invalidation.

  In this same vein, =---ast-langtest= to get the LISP-like AST output used in LangTest.
- [Meta]: Fix abuse of =ast.hh=

  It's just far too far-reaching, all-encompassing.

  Ideally, we'd /at least/ separate the definitions of the "base" types (Expr, Type, Loop) and the "final" types (ReturnExpr, etc).
- [Sema]: =---no-default-handlers=
  If passed, do not include definitions for the functionality that Sema generates calls to, for example (i.e. =__dynarray_grow=).
- [Lexer]: Disallow =_X= anywhere in identifiers (for mangled name compatibility)
- [Feature]: Compiler removes unnecessary type annotations (i.e. where deduction is possible)
- [Fix]: Compound literal initialiser should act as if it was cast to var type.
  Current:  =bar : T T !{42};=
  Proposed: =bar : T !{42};=

* LangTest

- [Deduplication]: Better facilities for parsing lang tests.
  I want a generic way to split a LangTest-like file (i.e. ~====~ fences around lines with names and =:= specifiers followed by a block of arbitrary text delimited by a =---= fence, followed by more arbitrary text).
  Then, in LangTest, we can just parse the test into these known chunks and extract the relevant information from each.
- [LangTest]: fail test specifier given an expected error id in brackets
  i.e. =:fail_sema["invalid-literal/integer"]= or something to make sure the /expected/ diagnostic is emitted, not just a similar one.
- Write an IR LangTest implementation.
  NOTE: Sort of not applicable because IR parser does not build an AST.

* RunTest

- [Glint] Delete generated gmeta files
  We should probably just delete all of them in the directory after we are done, or something (rather than try to delete each one as it's generated, like we do with other artifacts).
