#+created: <2022-08-01 Mon>

* FUNCompiler

I didn't really have a plan, but I went ahead and started making this
compiler from scratch in C anyways. Now we have a functioning compiler
with a brand new language that has still not even been named.

** Usage

Run the executable from a shell with a path to some source code as the
only argument. Currently, we print out the furthest progress we are
able to make. Eventually, we will output compiled source code.

** Building

Dependencies:

- [[https://cmake.org/][CMake >= 3.14]]

- Any C Compiler (We like [[https://gcc.gnu.org/][GCC]])

First, generate a build tree using CMake.
#+begin_src shell
  cmake -B bld
#+end_src

Finally, build an executable from the build tree.
#+begin_src shell
  cmake --build bld
#+end_src

*** To build generated x86_64 ASM

#+begin_src shell
  as code.S -o code.o
  ld code.o -o code
#+end_src

** Language Reference

The language is statically typed.
Variables must be declared and type annotated before use.

Whitespace is ignored and there are no required expression delimiters.
That's right: no semi-colons and no forced indent!

Functions are first-class citizens, or at least should be eventually.

A program in this language comes in the form of a file. The file may
contain a series of expressions that will be executed in order, from
top to bottom. There is no =main= function or other entry point;
control flow starts at the very top of the file and makes it's way to
the bottom of the file.

Let's take a look at a basic program:
#+begin_example
defun fact (n : integer) : integer {
  if n < 2 {
    1
  } else {
    n * fact(n - 1)
  }
}

fact(4)
#+end_example

This program will return 24 as a status code. The result of the last
expression in the file is the return value. The same holds true for
function bodies, and if/else bodies.

Variables in a local scope shadow variables in a parent scope, and may
share the same symbolic name.
