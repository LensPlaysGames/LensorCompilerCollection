#+created: <2022-08-01 Mon>

* Lensor Compiler Collection

Often abbreviated /LCC/, the Lensor Compiler Collection is a collection of compilers (frontends) that target /LCC IR/, libraries that perform operations on LCC IR, and code-generating libraries (backends).

LCC exists so that you may implement your language without
- A.) having to learn GCC internals, and
- B.) having to build LLVM (/can/ your computer even do it?).

The mantra: no third-party dependencies. Everything in-house and from scratch. This prevents beginners running into unending linker errors (ahem, LLVM), as well as having to figure out all the right flags and options to pass to a configure script (ahem, GCC). While this does create head-aches (/shudders in register allocation/), it also means that nothing is "hidden". If you want to know how something works, the code is right here in the codebase, written in a familiar style.

** Usage

For convenience purposes, there is a single executable, ~lcc~, that can delegate between all of the different compilers in the collection. This is called the /compiler driver/, often shortened to just /driver/. Languages may choose to implement a standalone executable that only compiles their language, but it is not required, and they are not built/distributed by default.

Running the driver executable with the =--help= argument will display a usage message that contains compiler flags and options as well as command layout.

The driver, by default, uses file extension to determine which language to treat the source as. ~lcc examples/glint/SimpleFile.g~ will treat the contents as ~Glint~ source, while ~lcc tst/ir/roundtrip.lcc~ will treat the contents as LCC IR, for example . You can use ~-x LANG~ to treat source files as a particular language, regardless of extension.

** Building

Dependencies:

- [[https://cmake.org/][CMake >= 3.20]]

- Any C++ Compiler (We like [[https://gcc.gnu.org/][GCC]])

NOTE: If on Windows *and* using Visual Studio, see [[file:docs/VISUAL_STUDIO.org][this document]] instead. Also, switch to Linux :^).

First, generate a build tree using CMake.
#+begin_src shell
  cmake -B bld
#+end_src

Finally, build an executable from the build tree.
#+begin_src shell
  cmake --build bld
#+end_src

You'll probably want to build it in parallel, otherwise it might take a minute.
#+begin_src shell
  cmake --build bld --parallel 7
#+end_src

** Implemented Languages

In the future, we hope to support

- some of C
- YOUR language :) (it's easy!! really)

*** Glint | Low Level, Higher Order

See [[file:docs/glint/][relevant documentation]].

- Separate Compilation (via Modules system)

This allows build tools to parallelize the embarrassingly parallel problem of compilation.

- Functional Programming in an Imperative Language

- Meta Programming via templates; compile-time code generation.

- =name : type= syntax (vs C =type name=).

- Out of order (function) declaration
