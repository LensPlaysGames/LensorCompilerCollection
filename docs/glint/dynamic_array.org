* Glint's Dynamic Array Type

It's a vector.

The dynamic array type attempts to make a generic container type that may be used for all or most non-performance applications.

A dynamic array is basically a fancy way to make a struct, and a fancy way to operate on structs created in that way...

=[byte]= is equivalent to =struct { data: byte.ptr; size: uint; capacity: uint; }=. You can access these members on any instance of a dynamic array.

In C++, =std::vector=.

In Rust, =Vec=.

** Operations

- Binary =+== :: append rhs to dynamic array on lhs (i.e. =foo:[byte]; foo+=`0`;=).
- Binary =~== :: prepend rhs to dynamic array on lhs (i.e. =foo:[byte]; foo~=`0`;=).
- Binary =[= (Subscript) :: Rewritten to subscript of data member of dynamic array.
- Trinary ~[=~ :: insert rhs at index given at mhs into dynamic array on lhs (i.e. =foo:[byte]; foo[=0, `0`;=)
  NOTE: If index is not within the inclusive range of 0 to size, the program will crash.
  If it didn't, iteration may expose values that have not been initialized properly.

** Accessing Elements

*** Sugar

Subscript of the dynamic array itself acts as a bounds-checked subscript of the data member of the dynamic array.

#+begin_src glint
  out : [byte];
  out += 69;

  out[0] ;; out.data[0]
  @out[0]; ;; 69
#+end_src

*** Basic

Dereference the data pointer, basically.

#+begin_src glint
  out : [byte];
  out += 69;

  @out.data[0]; ;; 69
#+end_src

** Range-based Loops

Glint's =for= keyword works on any type with =data= and =size= members, which includes dynamic arrays. You can iterate every element of a dynamic array using =for=.

** Allocating Memory

As you may already know, a dynamic array/vector allocates memory at runtime to store values in. These allocations are /implicit/ in Glint. That is, the act of creating a dynamic array has the side effect of allocating memory.

So, uh, when does it get freed?

The programmer is responsible for freeing the allocated memory using the unary minus operator =-=. It is an error in a Glint program for a dynamic array to be created and never be freed. This means, for the most part, that Glint programs are statically checked to be memory safe regarding use-after-free errors.

The only time the programmer is not responsible for freeing the allocated memory of a dynamic array is when that dynamic array is automatically inserted by the compiler. In that case, the compiler is also required to insert it's de-allocation.
