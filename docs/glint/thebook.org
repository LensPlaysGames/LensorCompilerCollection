#+title: Programming in Lensor Glint
#+author: lens_r
#+created: 2025-11-04
#+options: ^:{}
# Do not export answer drawers
#+options: d:(not "answer")

#+begin_src emacs-lisp :exports none
  (defun lens/export-the-book ()
    "Export the book when it is your current buffer"
    (interactive)
    (org-latex-export-to-pdf)
    (org-ascii-export-to-ascii))
#+end_src

* Programming in Lensor Glint

NOTE: Glint is a language, Lensor is the specification of the language described by this book.

** Introduction, Overview

*** History

Glint started in 2023 when Lens_r decided he wanted to make a compiler, from scratch, for fun. That compiler needed to compile a language, and so he made one up. At first, it had no name, and was referred to as "the language the FUNCompiler compiles"; as you may have guessed, that grew tedious rather fast, and we needed a name.

That's when Glint got it's name: /Intercept/. Yes, it was named something else for the first year or so. It was renamed Glint when the language itself was cleaned up and made more opinionated toward important design goals, and the language kind of outgrew it's initial version, looking nothing like it used to (and as such, felt deserving of a new name).

The hope is that, even if this language doesn't change your perceptions entirely, or blow your mind, you'll be able to see a glint of promise in an otherwise dark world =:^)=.

*** Example Program

#+begin_src glint
  ;; Comments may be placed in the source to explain the program and/or make
  ;; it easier to understand. They begin with ;; and end with a newline or
  ;; end of file (EOF).

  ;; Some Glint tooling (namely glintdoc) makes use of special comments that
  ;; precede declarations. They usually contain @ directives.

  foo : int;

  ;; @returns updated value of 'foo'.
  ;; @see foo;
  getset_foo : int()
    foo := ++foo;

  ;; The final expression in the program is returned.
  69;
#+end_src

*** Program Structure

A Glint program consists of:
- Header :: The first portion of the file designates module status and imported dependencies.
- Comments :: Non-code portions of the file that are used to describe, annotate, and document the code portions of the file. Comments begin at =;;= and go until a newline or EOF.
- Expressions :: Code portions of the file that are used to tell the computer what to do; they are said to "return" a value of some type upon evaluation/execution.

*** Glint Exercise

# An exercise for the reader to explore and ensure their knowledge on the very basics of Glint program structure. The idea is to ensure they can read the examples coming up. I think the idea is to give an example program, and provide a small, five-question quiz for the reader to test their knowledge. i.e. "what is the first word of the 4th comment", "what is the first expression", etc.

#+begin_src glint -n
  ;; Declare some variables with initial values.
  a : int 42;
  b : byte 27;

  ;; @returns the sum of parameters x and y.
  foo : int(x : int, y : int)
    x + y; ;; adds x and y

  ;; Invocation of function foo with parameters a and b.
  foo a, b;
#+end_src

The following questions relate to the above example. If you don't know the answer to one, just keep reading and move on, it's okay; you can come back whenever you are ready.

1. On what line does the first /expression/ appear?
  # NOTE: answer drawers are not included in the export.
  # The idea is that I (or a program) will go through and write the answers
  # in the back of the book.
  :answer:
  2
  :end:

2. On what line does the comment with an @ directive appear?
  :answer:
  5
  :end:

3. Is there an expression on line 7?
  :answer:
  yes
  :end:

4. What would the result of the entire program be?
  :answer:
  69
  OR a + b
  :end:

5. Is there a comment on line 7?
  :answer:
  yes
  :end:

Extra credit:

6. How many parameters does =foo= take?
  :answer:
  2
  :end:

7. What kind of type is =foo= of?
  :answer:
  Function
  :end:

** Simple Values

or, Literals and Constants,
or, Self-evaluating Expressions.

*** Integers

Glint supports decimal, hexadecimal, octal, and binary integer literal formats; all except decimal are accessible through a special prefix that begins with =0=. A decimal number literal may not begin with =0=.

A hexadecimal number literal is prefixed with =0x=. =0xf= has the value of =f= in hexadecimal, or =15= in decimal.

An octal number literal is prefixed with =0o=. =0o25= has the value of =25= in octal, or =21= in decimal.

A binary number literal is prefixed with =0b=. =0b10= has the value of =10= in binary, or =2= in decimal.

*** Bytes

Glint makes no distinction between character and integer data types (unlike Pascal, and like C).

Glint provides a way to get the encoded byte value of a character as an integer value in the program, and that is to wrap the character in =`= (back-ticks).

=`0`= is equivalent to =48=.

Often, it can be messy to have control characters appear in the source code, so Glint provides an "escape" syntax, such that other, non-control characters may represent the control characters.

Relevant escape characters include =\n= for a line feed, =\\= for a =\= (backslash), and =\t= for a tab stop.

*** Boolean

Logical values that denote veracity of an expression.

=true= and =false= keywords to access these values.

*** Strings

A string allows the Glint programmer to include (textual) data directly from the source code into the final program as an array of byte values.

Inescapable strings are wrapped with ='= , and escape-able strings with ="=.

An inescapable string will contain the contents between the two ='=, verbatim. =\= is not special within an inescapable string. An inescapable string may span any amount of newlines.

='foo\﻿n'= -> [102, 111, 111, 92, 110, 0]

An escape-able string accepts the "escape" syntax that byte literals also accept.

="foo\﻿n"= -> [102, 111, 111, 10, 0]

** Variables

# Covers variables, scopes, declarations, maybe primitive types

A variable is a name we give to some Glint construct. In most cases, a variable refers to data at some address in memory; as such, it is sort of like a labeled, specialty box. The box may only contain the type of data the box is declared to contain, and the box may be referenced by it's name. Any value may go in the box, as long as it fits both in the box and through the opening.

A variable is a named location in the computer's memory at the time of evaluation.
You may store data at this named location for easier retrieval later on. The data is stored on a computer, and, as such, is in a binary format (just bits). However, Glint makes use of types of data that the hardware cannot understand, allowing the Glint programmer to write more idiomatic source code. You can think of types as an interpretation of the binary bits that are actually on your computer hardware when the code is running. The type of data that is stored at this location is declared by the programmer either explicitly or implicitly in a /declaration expression/.

*** Declaration Forms

A declaration expression may take on several different /forms/. All of these forms accomplish the same thing (declaring a variable), but in different ways and with different requirements.

The most standard form of declaration expression is an explicitly-typed variable.
#+begin_src glint
  x : int;
#+end_src

This sort of expression may be read as, "x is an integer".

This form may be built upon to include an initializing expression, placed directly after the type expression. In this way, it is equivalent in syntax to an explicit cast expression preceded by an identifier.
#+begin_src glint
  x : int 69;
#+end_src

This may be read as, "x is an integer with the value sixty-nine".

There is another form of declaration, though, that allows us to shorten a lot of code, and reduce duplicated type names in declarations: the type-inferred declaration expression form.
#+begin_src glint
  x :: 69;
#+end_src

This may be read as "x has the value of 69". The type of x will be set to whatever the type of the initializing expression is (in this case, =int=).

Uninitialized variables are default initialized, which, for the most part, means they have a value of zero (except for dynamic arrays, but, we'll get to that).

*** Type Decay

One of the more confusing parts of any type system is declaration type decay; as long as you aren't doing anything too weird, you'll never run into problems. But, if you are trying to pass functions as parameters to other functions, it becomes relevant. For now, just understand that some types are quite complex in Glint, but quite simple in the underlying implementation, and that means that sometimes you want the simple underlying implementation rather than all the complexities that come with the Glint type (if that makes any sense).

*** Scopes

A /scope/ is a concept of a meaningful collection of declarations. For example, the body of a function is within a new scope, such that any variable declarations are not accessible from outside the function.

A Glint programmer may open a scope manually by using a block expression; the contents of which is within a new scope.

Whenever a new scope is created (or /opened/), it is given a parent scope; if a name lookup doesn't match in the enclosing scope, the parent will be searched until either the name is found or there are no more parent scopes.

#+begin_src glint
  x : int;

  {
    y : int;
  }

  y; ;; Error! Unknown symbol y'
#+end_src

The scope structure of the above program might look something like the following. (NOTE: Simplification for explanation purposes: leaves out global and top level scope).
#+begin_example
root
|-- x
`--block
   `-- y
#+end_example

When we "exit" the block expression, the scope is exited as well; further expressions are once again within the parent scope.

If we were to lookup =x= from the =block= scope, we would not find it in the enclosing scope, search the parent (=root=), and find it. This means that =x= is accessible from the block scope, and it would not be an error to use it there.

On the contrary, if we were to lookup =y= from the =root= scope, we would again not find it in the enclosing scope; but, there is no parent of the =root= scope, so we are done searching. Because we exhausted the search of scopes and did not find a matching declaration, that means this symbol is not valid at this point in the program. That is why the above use of =y=, outside of the block expression, is invalid.

In Glint, shadowing is not allowed, so you cannot actually declare a variable of the same name as another if both would be valid at that point.

#+begin_src glint
  x : int;
  { x : int; } ;; Error! Redeclaration of 'x'
#+end_src

The following is a non-exhaustive list of expressions which have containing expressions that are parsed in a different scope.

- Block Expression
- If Expression
- Else Clause
- For/CFor
- Function Body
- Each Match Expression

*** Assignment

Assignment is the operation of setting a variable's value, such that further accesses to the variable result in the set value. Assignment uses the =:== operator (like Pascal). Assignment destructively modifies the values in memory associated with the given variable. After assignment, any value that was held in the memory /before/ the assignment is destroyed, and can not be accessed.

#+begin_src glint
  x : int;

  ;; This is an assignment!
  x := 69;
#+end_src

# Mention extended assignment operators i.e. -=

Often, you want to use the variable itself in the calculation of the new value of the variable; there are short-hands for lots of operations mixed with assignment.
#+begin_src glint
  x :: 42;
  x += 27; ;; Now, x = 69
#+end_src

*** Glint Exercise

Exercise Mission
- Recognize declarations of any form.
- Differentiate variable names, types, and initializing expressions.
- Reason about the values variables have at different points in the control flow of the program.

#+begin_src glint
  x : int;
  y : int = 420;

  ;; y := y - x;
  y -= x;

  x := 351;

  z :: y - x;
#+end_src

The following questions relate to the above example.

1. What is the name of the first variable declared?
  :answer:
  x
  :end:

2. How many variables are declared?
  :answer:
  3
  :end:

3. What is the value of variable 'y' when the program starts, and when the program finishes?
  :answer:
  420, 420
  :end:

4. What is the initial value of 'z'?
  :answer:
  69
  :end:

5. What is the type of 'z'?
  :answer:
  int
  OR the common type of 'y' and 'x'
  :end:

6. What is the value of the variable 'x' when the program starts, and when the program finishes?
  :answer:
  0, 351
  :end:

** Basic Expressions

*** Arithmetic

Glint programs often need to do basic math; for this, there are the arithmetic operators. These include the standard addition (=+=), subtraction (=-= ), multiplication (=*=), division (=/=), and modulo (=%=).

*** Bitwise

On computers, data is represented as bits. Bitwise operations allow you to operate directly on the data bits, rather than on sets of bits with some applied semantics (i.e. an 8-bit signed byte). Bitwise operations include AND, OR, XOR, and NOT.

*** Implicit Casting

# What types of coercion are allowed.

In Glint, the philosophy is that you should have to write less code /when you can/. That means that, as long as everything is clear to the compiler, you don't need to mark up your program with meaning that is already implied. This reduces the code the Glint programmer has to write, and, in turn, reduces chances that they may introduce a bug.

An integer is implicitly convertible to a boolean, and vice versa.

For integer to integer casts, it is valid if the bitwidth we are casting from is less than or equal to the bitwidth we are casting to, OR, if the values are known at compile time, if data is preserved through performing the cast.

A struct is implicitly convertible to any supplanted member.

A fixed array is implicitly convertible to an array view.

A dynamic array is implicitly convertible to an array view.

Functions are implicitly convertible to their corresponding function pointers.

Functions with no parameters are implicitly convertible to their return type.

Pointers are convertible to =void.ptr=.

*** Explicit Casting

To treat a variable's memory as if it were of another type, you can explicitly cast a value. To do this, simply invoke the type with a single argument of the type you'd like to cast.

To cast integer =42= to =byte=:
#+begin_src glint
  byte 42;
#+end_src

*** Glint Exercise

# Gotcha test with explicit cast of a large value to a small type.

** Glint's Print

# How printing stuff works.

*** Glint Exercise

# "what is the output of the program?"
# "what would the output of the program be if 'x' was '3'?"

** Arrays

*** Fixed Arrays

# Mention how these are what string literals are.

*** Dynamic Arrays

*** Array Views

*** Initializing Array Views

*** Initializing Fixed Arrays

*** Initializing Dynamic Arrays

** Conditionals and Control Flow

# Mention programs are executed in order.

# if, and logical operators.

# while, cfor, for, match

*** =if=

=if= evaluates a condition expression, and, if the result is truthy, evaluates a body expression. Optionally, when an =else= clause is present, a different body expression will be evaluated if the result of evaluating the condition expression is falsy.

#+begin_src glint
  if condition, body;
#+end_src

#+begin_src glint
  if condition,
    then
  else otherwise;
#+end_src

*** =while=

=while= evaluates a condition expression, and, if the result is truthy, evaluates a body expression. After evaluating the body expression, it will jump back to evaluating the condition expression.

#+begin_src glint
  while condition, body;
#+end_src

*** =for=

=for= is a loop structure that will iterate over anything with =data= and =size= members (like dynamic arrays or array views). It provides a reference to the corresponding element for each iteration.

#+begin_src glint
  for element in container, body;
#+end_src

*** =cfor=

=cfor= is a control structure that mimics C's =for=.

#+begin_src glint
  cfor init; condition; increment; body;
#+end_src

*** =match=

=match= selects a control flow depending on which member of a sum type is held.

=match= must handle every possible member a sum type may have.

#+begin_src glint
  match value_of_sum_type, {
    .member0 expr;
    .member1 expr;
  };
#+end_src

** Declared Types

# structs, unions, enums, and sums.

# Using compound initializer

*** Supplanted Members

** Basic Functions

# what it is

A /function/ is a concept that programming borrows from mathematics.

Remember \( f(x) \) in math class? That is a /function application/. What it means is that, =f= is some operation (or sequence of operations) that we would like to apply to =x=. Hence, /application/.

# what it do be

In programming, we've extended math to suit our use-case; variables have types associated with them, for example (not really a thing in math: numbers are numbers).

Functions are no different; programming extends them to better fit the common use-cases.

# parameters

Just like in math, Glint functions may have any amount of parameters.

Remember =f(x)= from before? =x= is a /function parameter/. =f= is said to be a function with a single parameter. A parameter is a variable (as in, it may vary) value that may change upon different invocations of the function. You may think of it like a name for a placeholder value that will be filled in at some later point.

- On Parameters vs Arguments :: Parameters appear in the function declaration and definition, while arguments appear in each function invocation. An argument is the value that a parameter takes on during a particular invocation of a function.

# returning values

Functions do not /just/ execute an operation, or sequence of operations, though. They apply operations in order to form a result value, which is then said to be "returned from" the function, upon application. In Glint, the result of evaluating the last expression in a function is the return value, unless otherwise explicitly returning via =return=.

A function's return value is constrained to be of the declared return type of the function (such that uses of the function may rely upon a binary format of the returned value).

# when it should be

Basic functions allow the programmer to de-duplicate code, increase readability, and form custom control flow.

You should write a function when you find yourself writing the same set of expressions over and over, with just a few values swapped out for another in each set. Instead, extract that set of expressions into a function body, then invoke that function each time you need to do that set of operations.

Basic function example:
#+begin_src glint
  foo : [int 2] !{ 69, 42 };
  bar : [int 2] !{ 27, 42 };
  baz : [int 2] !{ 64920, 42 };

  @foo[1] *= 10;
  @bar[1] *= 10;
  @baz[1] *= 10;
#+end_src

With a function:
#+begin_src glint
  foo : [int 2] !{ 69, 42 };
  bar : [int 2] !{ 27, 42 };
  baz : [int 2] !{ 64920, 42 };

  ten_times_second : void(x : [int 2])
    @x[1] *= 10;

  ten_times_second foo;
  ten_times_second bar;
  ten_times_second baz;
#+end_src

As you can see, when proper names are picked, functions increase the ability for code readers to understand what the code is trying to do (vs what it may actually be doing). They also allow for easier refactors; imagine you want to also multiply the first value of every array by 3. That would be one expression, one extra line of Glint code to write in the function body. Without a function, you'd have to write and edit that line of code where every invocation is! For this simple example, it would be doable, but, with a large and growing codebase, that becomes more and more difficult.

** Pointers and References

We've talked a little about how variables (for the most part) are named locations in the computer's memory. When we say memory, we mean it's RAM (/Random Access Memory/). RAM is (usually) a linear set of addressable bytes that the CPU may read from and write to.

When we say /addressable/, we mean that there is a unique way of referring to each and every byte within that linear set. Mostly, this is done simply by index, and we call this index a /memory address/.

A /pointer/ is simply a memory address; an index into that linear set of bytes that the CPU can do whatever it wants with. In Glint, pointers have an associated underlying type; the type tells Glint how to interpret the value in memory at that memory address. So, a value of type =int.ptr= (a pointer to an integer) will be some index into the linear memory array; we don't really care what it is. If we were to =load= the value at that memory address (technically the next eight values, since an =int= is eight bytes), we would then have a value of type =int=.

# Glint subscript doesn't dereference.

In Glint, subscripting is the act of offsetting a pointer by some multiple of the size of a given type. So, to continue with our last example, subscripting a value of type =int.ptr= by one would increase the value by eight, since that is the size in bytes of an integer. The idea is, the first subscript of a pointer gets the address where the next element in contiguous memory would be, if there were one. This applies to every value, not just the first, so the zero-eth subscript leaves the pointer unchanged, while the second subscript increases the pointer by the size of two elements (sixteen bytes in the case of =int.ptr=).

Do keep in mind that, unlike most other languages, Glint's subscript does *NOT* dereference. That is, the act of subscripting does not load any values in Glint; it simply calculates the memory address. In order to load a value from a memory address, you have to dereference it. In Glint, that is done via the unary prefix operator =@= (i.e. get the value "at" the given memory address).

** Templates

# Mention differences between C++ templates and Glint templates (Glint's templates are lower level, and invocable expressions without a special syntax).

Templates, at their core, are expressions which evaluate to other expressions.

A template is a special form of expression that results in an expression upon evaluation. You can think of it as code that generates code.

This is often useful when you have some expression (or set of expressions) that end up being duplicated throughout a function, with just a few values swapped out for different ones here and there.

First, let's look at the most basic template expression: the /identity/ template.

#+begin_src glint
  template(x : expr) x;
#+end_src

This template expression, when invoked with an expression, would evaluate to that argument expression unchanged.

Often, you want to use a template more than once; for convenience, a Glint programmer may name a template expression. This may also improve readability. Remember that templates are NOT functions! They are their own type of invocable (callable) expression.

#+begin_src glint
  identity :: template(x : expr) x;

  ;; Evaluates to '69420'.
  identity 69420;
#+end_src

# TODO: example of binary read

** Function Overloading

# Show a basic, real-world use-case

Glint supports /function overloading/, which is the idea of giving multiple definitions to a single, named function; each definition differs in their signature (return type and/or parameter types), and the compiler determines which definition to call at each call site based on the types of the argument expressions.

#+begin_src glint
  ;; [0]
  make_byte : byte(v : int)
    byte v;

  ;; [1]
  make_byte : byte(v : byte)
    v;

  make_byte 69; ;; calls [0]
  make_byte `0`; ;; calls [1]
#+end_src

** Operator Overloading

/Operators/ are tokens, or sequences of tokens, that may be placed somewhere around an expression in order to alter the result of the expression in some way. Operators may be defined by how many inputs they operate on (/arity/), as well as where the operator is placed in relation to the inputs (prefix, infix, or postfix). An operator that comes before the single expression it operates on would be a /unary prefix operator/. An operator that sits between the two expressions it operates on would be a /binary infix operator/.

For simple types like pointers or integers, an operator will map quite neatly to one (or a minimal amount of) machine instruction(s), so there is really no advantage to defining functions for these operations; instead, we insert the instructions directly.

However, in Glint, a programmer may declare their own types, as well as variables with values of those declared types. The programmer may want to take advantage of these operators for their own types; to accomplish this, Glint inserts calls to specially-named functions when these custom types are used in these operators that normally wouldn't support them. The programmer may then define these functions themselves, customizing the code that runs when these operators are used.

TODO: syntax example
# operator[] ?
# __op_subscript?

** Templated Functions, Templated Types

You do not ever need to implement a vector in Glint, as there is the dynamic array type built-in to the language. However, vectors are simple to understand, and widespread enough that I believe this to be the best (as in least-confusing) example to give.

A templated type is like a template expression that defines a type.

TODO: Syntax not final.
#+begin_src glint
  vector :: struct templated {
    data : (auto).ptr;
    size : uint;
    capacity : uint;
  };

  my_vec_of_int : vector int;
#+end_src

A templated function is like a template expression that defines a function.

#+begin_src glint
  vector_push : void(vec : (vector auto.element).ref, val : auto.element) {
    if vec.size + 2 > vec.capacity,
      vector_grow vec;

    @vec.data[vec.size] := val;
    vec.size += 1;
  };
#+end_src

Now, upon invocation of =vector_push=, the compiler will first look for a defined function with the signature matching the given arguments (i.e. =auto.element= is =int=). If it exists, it will call it. If it doesn't, it will use the templated function's body as a template body and expand it with the given type(s). It will then call that defined function.

#+begin_src glint
  vector_push :: template(element : type)
    vector_push_impl : void(vec : vector element, val : element)
      ...;

  ;; Invocations could be thought of like this
  (vector_push int) my_vec_of_int 69;
#+end_src

Basically, a templated function is shorthand to define a template that defines a unique function for every unique set of types passed in place of =auto= in the parameters.

** Modules

*** Writing A Module Vs A Program

A Glint program is a collection of Glint source code that may be compiled and linked to an executable. A Glint program may import Glint modules.

A Glint module is a collection of Glint source code that does not compile to executable, but rather a library. This library then may be used by a linker to include it's code in a separate executable. This library is also used by the Glint compiler to resolve the Glint module's metadata that produced it when compiling code that imports the module.

Programs and modules may import modules, but neither programs nor modules may import programs.

*** Exporting Variables

*** Importing Modules

** Example Programs

*** Recursive Fibonacci

#+begin_src glint
  fib : uint(n : uint) {
    if n <= 1, return n;
    (fib n - 1) + (fib n - 2);
  };

  ;; Calculate 7th number in the Fibonacci sequence, and return that.
  fib 7;
#+end_src

Writing this example actually caught a bug in the compiler implementation regarding IR generation; see commit 9d152973, if interested.

*** Euclid GCD

#+begin_src glint
  gcd : uint(a : uint, b : uint) {
    if b = 0, return a;
    gcd b, a % b;
  };

  ;; Calculate the greatest common denominator of 32 and 80, and return
  ;; that.
  gcd 32, 80;
#+end_src
