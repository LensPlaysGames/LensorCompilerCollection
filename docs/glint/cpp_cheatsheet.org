#+options: H:4 num:3 toc:3

* C++ <-> Glint Cheat Sheet

How to do things in both.

** =std::vector<T>= <-> =[T]=

*** Append

**** C++
#+begin_src cpp
  vector.push_back(value);
#+end_src

**** Glint
#+begin_src glint-ts
  dynamic_array += value;
#+end_src

*** Prepend

**** C++
#+begin_src cpp
  std::insert(vector.begin(), value);
#+end_src

**** Glint
#+begin_src glint-ts
  dynamic_array ~= value;
#+end_src

*** Insert

**** C++
#+begin_src cpp
  std::insert(vector.begin() + index, value);
#+end_src

**** Glint
#+begin_src glint-ts
  dynamic_array[index] += value;
#+end_src

*** Access

**** C++
#+begin_src cpp
  vector.at(index);
#+end_src

**** Glint
#+begin_src glint-ts
  @dynamic_array[index];
#+end_src

*** Range-based For Loop

**** C++
#+begin_src cpp
  for (auto elem : vector) {}
#+end_src

**** Glint
#+begin_src glint-ts
  for elem in dynamic_array, {};
#+end_src

*** Manual For Loop

**** C++
#+begin_src cpp
  for (auto i = 0; i < vector.size(); ++i) {}
#+end_src

**** Glint
#+begin_src glint-ts
  cfor
      i :: 0;
      i < dynamic_array.size();
      i += 1;
    {}
#+end_src



** =std::print()=\slash{}Â =std::cout= <-> =print=

*** Simple

**** C++
#+begin_src cpp
  std::print("{}", value);
#+end_src

**** Glint
#+begin_src glint-ts
  print value;
#+end_src

*** With Newline

**** C++
#+begin_src cpp
  std::print("{}\n", value);
  std::println("{}", value);
  std::cout << value << '\n';
  std::cout << value << std::endl;
#+end_src

**** Glint
#+begin_src glint-ts
  print value, `\n`;
#+end_src

** =std::variant<T>= <-> =sum=

**** C++
#+begin_src cpp
  std::variant<int, char>;

  std::variant<int, char> foo;

  foo = 420;

  static_assert(std::variant_size_v<decltype(foo)> == 2);
  if (std::holds_alternative<int>(foo)) {
      std::println("69");
  } else if (std::holds_alternative<char>(foo)) {
      std::println("42");
  } else std::exit(1);
#+end_src

**** Glint
#+begin_src glint-ts
  ;; Note: Glint's sum type can represent multiple members of the same type,
  ;; distinguished by name.
  sum { x : int; y : int; z : byte; };

  foo : sum { x : int; y : int; z : byte; };

  foo.y := 420;

  ;; `match` already staticly asserts all members are handled.
  match foo, {
    .x  print 69;
    .y  print foo.y;
    .z  print 42;
  };
#+end_src
