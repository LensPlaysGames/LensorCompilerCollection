# Created 2025-09-27 Sat 13:38
#+title: 
#+author: Rylan Kellogg
* Preface

This document is manually generated and may be a couple commits behind.
* Glint Programming Language

The Glint programming language is a high level programming language with low-level capabilities. Focused on the programmer, the Glint programming language spearheads ease of use while also letting people who know what they are doing, do it better.

If you are new to Glint, keep in mind that subscript doesn't dereference. =x[0]= is of pointer type, to get the value at that pointer you need to use =@x[0]=. The only way to achieve pointer arithmetic in Glint is through the subscript operator.

The subscript operator is also the only way to get a pointer from an array type.
** Glint's Literals

A literal is defined as fixed values embedded in the source code. Also known as self-evaluating expressions.
*** Number Literals

#+begin_src lisp
  69 420 ;; regular decimal literals
  ;; 042 ;; ERROR! Leading zeroes not allowed

  0b0 0b01000101 ;; regular binary literals
  0o0 0o377      ;; regular octal literals
  0x69 0xbeef    ;; regular hexadecimal literals

  1'004       ;; decimal literal with separator
  0b0010'0100 ;; binary literal with separator
  0xb0'0b     ;; hexadecimal literal with separator
#+end_src

A number literal is of integer type.
*** String Literals

A string is a contained sequence of bytes in the source code that is converted into data that is embedded in the final program.

#+begin_src glint-ts
  '' 'i am data?' ;; regular string literals

  "" "i\'m data?" ;; escapable string literals
#+end_src

A string literal is of array of byte type.
*** Byte Literals

Sometimes, it's convenient to get a number representation of a byte in the source code (i.e. =0= or =a=). Mostly for ASCII math stuff, to be honest, but still needed often enough to be necessary.

#+begin_src glint-ts
  `6` `9` `A` ;; regular byte literals

  ;; `` ;; ERROR! Empty byte literal
#+end_src
*** Boolean Literals

There are two of them.

#+begin_src glint-ts
  true
  false
#+end_src
*** Compound Literals

A way to write a literal of more complex types (like structs).

Just a list of expressions separated by soft separators, with the extra ability to name expressions.

#+begin_src glint-ts
  ;; regular compound literals
  !{}; !{420}; !{420, 69};

  ;; compound literal with named expressions
  !{.value 420}; !{.x 420, .y 69};
#+end_src
** Glint's Dynamic Array Type

It's a vector.

The dynamic array type attempts to make a generic container type that may be used for all or most non-performance applications.

A dynamic array is basically a fancy way to make a struct, and a fancy way to operate on structs created in that way...

=[byte]= is equivalent to =struct { data: byte.ptr; size: uint; capacity: uint; }=. You can access these members on any instance of a dynamic array.

In C++, =std::vector=.

In Rust, =Vec=.
*** Accessing Elements

Dereference the data pointer, basically.

#+begin_src glint-ts
  out : [byte];
  out += 69;

  @out.data[0];
#+end_src
*** Range-based Loops

Glint's =for= keyword works on any type with =data= and =size= members, which includes dynamic arrays. You can iterate every element of a dynamic array using =for=.
*** Allocating Memory

As you may already know, a dynamic array/vector allocates memory at runtime to store values in. These allocations are /implicit/ in Glint. That is, the act of creating a dynamic array has the side effect of allocating memory.

So, uh, when does it get freed?

The programmer is responsible for freeing the allocated memory using the unary minus operator =-=. It is an error in a Glint program for a dynamic array to be created and never be freed. This means, for the most part, that Glint programs are statically checked to be memory safe regarding use-after-free errors.

The only time the programmer is not responsible for freeing the allocated memory of a dynamic array is when that dynamic array is automatically inserted by the compiler. In that case, the compiler is also required to insert it's de-allocation.
** Glint's Sum Type

It's a sum type.

You can store multiple variables in the space that a single variable takes up, and keep it type-safe the whole time.

To define a sum type:
#+begin_src glint-ts
  sum {
    x : int;
    y : [byte];
  };
#+end_src

In C++, =std::variant=.

In Rust, =enum=.
*** =has= and =match=

Let's call this sum type =foo=.
#+begin_src glint-ts
  foo : sum {
    x : int;
    y : [byte];
  };
#+end_src

Now, any instance of this type may have EITHER the =x= member, OR the =y= member. Only one member is valid at one time. To check if a given member is valid, use the unary prefix operator =has=.
#+begin_src glint-ts
  foo : sum {
    x : int;
    y : [byte];
  };
  bar : foo;

  if has bar.x, ...
#+end_src

As you can imagine, this could get quite cumbersome quite quickly; adding a member to the sum type may mean tracking down long =if has= chains all over the codebase. If you forgot one, it could be catastrophic for your program! This is where =match= comes in. =match= lets you pick a different control flow based on the member held in any given instance of a sum type. =match= requires that all sum type members are handled.

#+begin_src glint-ts
  foo : sum {
    x : int;
    y : [byte];
  };
  bar : foo;

  out : int;
  match bar {
    .x: out := bar.x;
    .y: out := 69;
  };
  out;
#+end_src

As you can see, sum types allow you to define generic types while still retaining type safety. You could say that sum types allow you to define a variable that is one of a group of other types.
** Print

When all you want to do is see something...

Use =print= keyword to begin a list of expressions whose results will be printed.

=print 42;= will print =42= to standard out (or whatever you've defined the int formatter to do).
*** How it works

=print= is sort of like a fancy macro. It just gets converted into other code. Namely, every argument expression =E= is /placed into/ the following template, and then replaced with the template result.

#+begin_src prog
  {tmp :: format(E); puts(tmp.data); -tmp;};
#+end_src

As you can see, the single argument expression is converted into a block expression containing three expressions: a call to =format= (implemented in Glint), a call to =puts= (part of LibC), and a decrement of the dynamic array that format returns, which frees the associated memory.

However, if the argument is already of "dynamic array of byte" type, the call to =format= and the decrement will not be inserted. The same goes for arguments of =byte.ptr= type, fixed array of byte, view of byte, etc.

FUN FACT: If/when Glint ever gets AST-level macros, know that it is inspired by =print= (and thought of during it's implementation, because replacing AST nodes by hand, well, sucks).
** Glint's Identifier Escape

Let's say you want to call a variable =module=. Er, that's sort of tough, because, when you write =module= in the source code, it thinks it's a =ModuleExpr= or something and there are errors when trying to compile.

To fix this, you can write a backslash before the token you would like to treat as an identifier. So, by writing =\module= in the source code, you could feasibly call a variable =module=.

You could also use this to call a variable any other keyword in the language, like =\if= for =if=, or =\return= for =return=. This means that, ideally, the language itself should never get in the way of the programmer.
** Glint's Templated Expressions

In Glint, templates look a lot like functions, BUT THEY ARE NOT FUNCTIONS. If you only remember one thing from this file, let it be that warning. Please heed; so on--so forth.
*** Template Expressions

The simplest valid template is the identity template.
It effectively just applies a type constraint at compile time to whatever argument you pass to it.
#+begin_src glint-ts
  template(x : int) x;

  ;; ends up as
  ;; TemplateExpr
  ;; |-- Body: NameRefExpr
  ;; `-- Parameters...: VarDecl
#+end_src

Now, the above source code represents a /Template Expression/. It is an expression that may be invoked to generate an actual, "concrete" expression. That is, the above template does not end up in the final code of the program.
*** Named Template Expressions

You may also assign a template expression to a name.
#+begin_src glint-ts
  my_template :: template(x : int) x;

  my_template 69;

  ;; ends up as
  ;; IntegerLiteral
#+end_src
*** =type= Type

It should be known that, since template invocations are expanded at compile-time, the type of a template parameter may be a =type= itself. That is, a template argument may be a type expression.

#+begin_src glint-ts
  foo :: template(x : type) x;

  bar : foo int; ;; expands to 'bar : int'
#+end_src

This is useful for Glint module authors to export templates instead of concrete types.

#+begin_src glint-ts
  export vector :: template(elem_t : type)
      struct { data:elem_t.ptr; size:uint; capacity:uint; };

  foo : vector int;
#+end_src
*** Invoking a Template Expression

In order to actually use a template to "stamp out" code, we must invoke it (by calling it). The arguments we pass to it will be checked against the parameters declared within it.

#+begin_src glint-ts
  (template(x : int) x) 69;

  ;; ends up as
  ;; IntegerLiteral
#+end_src

As you can see, invoking a template expression removes the template expression from the program, and leaves just the body of the template with template parameters replaced with their argument counterparts.
** Glint's Token Macros

*** Theory

First, let's look at the first couple "steps" of compilation of a Glint program.

The Glint source code is read, and separated into logical units known as tokens. The tokens are used by the parser (or, more tersely, the syntactic analyser) to form a tree structure that represents the /meaning/ of the Glint program, or what it is meant to be doing.

#+begin_example
  SOURCE CODE
       |
       V
  LEXICAL ANALYSIS
       |
       V
  SYNTACTIC ANALYSIS
       |
       V
  SEMANTIC ANALYSYS
       |
       V
  ...
#+end_example

Okay, cool, why did we have to learn all that just to learn about lexer macros? Well, lexer macros are a way to "reach into" the Glint compiler from the source code.

#+begin_example
  SOURCE CODE<-----.
       |           V
       |           LEXER MACROS
       V           ^
  LEXICAL ANALYSIS-°
       |
       V
  ...
#+end_example

And, truthfully, once a macro has been lexed, it's application (or /expansion/) is more like this (where the lexer is operating on itself).

#+begin_example
  SOURCE CODE
       |
       |     ,-----LEXER MACROS
       V     V     ^
  LEXICAL ANALYSIS-°
       |
       V
  ...
#+end_example

So, why would we want to reach into the inner workings of the language? Most of the time, to do weird or stupid stuff, or to make life easier (and sometimes both!). Also, why not.
*** Practice

To begin a macro, we use the =macro= keyword.
To end a macro, we use the =endmacro= keyword.

The following is lexer macros in their simplest form.
#+begin_src glint-ts
  macro <name> emits <output> endmacro
#+end_src

Note that lexer macros do not require expression separators, as expressions have not yet been formed at the time of lexical analysis. There are only tokens. So, it could be said that the macro is "eaten" by the lexer (more accurately, the tokens that make up the macro's definition).

#+begin_src glint-ts
  macro empty_macro emits endmacro
  macro simple_macro emits 69 endmacro
  ;; macro emits endmacro; ;; invalid! no name :(
#+end_src

Writing =simple_macro= anywhere in the program following it's definition above will macro-expand into the number literal =69=.
*** Macro Parameters

A macro parameter is a token that is discarded upon expansion of the macro, but also enforced that it is there.

#+begin_src glint-ts
  ;; empty macro with '!' macro parameter
  macro foo ! emits endmacro;

  foo ! ;; expands to nothing
  foo ;; ¡ERROR! Ill-formed macro invocation: got '', expected '!'
#+end_src

This doesn't appear that useful in our little example, but it can be very powerful to enforce a syntax for something that is not supported in the language (i.e. braces wrapped around something means it is dereferenced, or something). It can also be useful when used in conjunction with macro arguments.
*** Macro Arguments

A macro may be given named parameters such that they may be duplicated in it's output.

#+begin_src glint-ts
  macro foo $x emits $x $x endmacro;

  foo 20 ;; expands to "20 20"
#+end_src

The idea is that, sometimes, you want to be able to take input into your macro to expand into different code based on what the user passes to it, not just a hard-coded sequence of tokens. This does that.

#+begin_src glint-ts
  macro foo + $x emits $x endmacro;

  foo + 20 ;; expands to "20"
  foo 20 ;; ¡ERROR! Ill-formed macro invocation: got '20', expected '+'
#+end_src
*** Macro Argument Selectors

Macro arguments may be given a single selector following the name identifier.

#+begin_src glint-ts
  $<name><selector>
#+end_src

- =:token= :: Captures a token. (default)
- =:expr= :: Captures a parsed expression rather than a lexed token.
- =:expr_once= :: Captures a parsed expression rather than a lexed token, and ensures that the expression is only ever evaluated once, no matter how many times it appears in the macro's output during expansion.

This becomes very powerful, as macros may operate on parsed expressions rather than lexed tokens. This reaches another layer further into the inner workings of the language, interacting with syntactic analysis.
*** Hygienic Expansion and Generating Symbols

#+begin_src glint-ts
  macro <name> defines <identifiers> emits <output> endmacro
#+end_src

=defines= allows the macro author to declare that the macro defines a variable. The compiler will give (or generate) that variable a unique name (or symbol) upon each invocation of the macro, such that weird shadowing errors do not occur. For example, if the macro user defines a variable named the same thing that the macro author uses, then the macro expansion would cause a redefinition error. Since nobody wants programs with errors, Glint provides the =defines= list so that any use of that defined identifier in the macro expansion will be given a unique name within that expansion.

The TL;DR is that =defines= allows you to create a definitely-unused name within a macro's output to avoid redefinition errors, and things like that.

#+begin_src glint-ts
  macro foo defines x emits x endmacro

  foo
#+end_src

This would emit an error: something like =Unknown symbol '__L0'=. The compiler generates a unique name, =__L0= in this case, to replace =x= with for each invocation. If we called =foo= again, we'd probably get =__L1= for that invocation, and so on and so forth.
